<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Noat Boat</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%9B%B3%3C/text%3E%3C/svg%3E">
  <script src="./fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
  <style>
    :root{
      --bg:#f2f2f2;
      --panel:#ffffff;
      --border:#d9d9d9;
      --text:#111;
      --muted:#666;
      --danger:#b00020;
      --btn-bg:#fff;
      --btn-hover:#f8f8f8;
      --topbar-gradient-start:#f7f7f7;
      --topbar-gradient-end:#efefef;
      --note-hover:#fafafa;
      --note-active-bg:#eef5ff;
      --note-active-border:#c9dcff;
      --search-focus-border:#b9d2ff;
      --search-focus-shadow:rgba(26,115,232,.12);
      --banner-bg:#fff7e6;
      --banner-text:#5a3b00;
      --editor-bg:#fff;
      --editor-grid:rgba(0,0,0,.025);
      --editor-grid-major:rgba(0,0,0,.04);
      --thumb-grid:rgba(0,0,0,.02);
      --thumb-grid-major:rgba(0,0,0,.035);
      --lightbox-bg:rgba(0,0,0,.72);
      --focus-overlay:rgba(235,235,235,.70);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --focus-strength: 0.70;
    }
    
    body.dark-mode {
      --bg:#1a1a1a;
      --panel:#252525;
      --border:#3a3a3a;
      --text:#e0e0e0;
      --muted:#999;
      --danger:#ff6b6b;
      --btn-bg:#333;
      --btn-hover:#3d3d3d;
      --topbar-gradient-start:#2a2a2a;
      --topbar-gradient-end:#222;
      --note-hover:#2d2d2d;
      --note-active-bg:#1e3a5f;
      --note-active-border:#2d5a8a;
      --search-focus-border:#2d5a8a;
      --search-focus-shadow:rgba(45,90,138,.25);
      --banner-bg:#3d3000;
      --banner-text:#ffd666;
      --editor-bg:#1e1e1e;
      --editor-grid:rgba(255,255,255,.03);
      --editor-grid-major:rgba(255,255,255,.06);
      --thumb-grid:rgba(255,255,255,.02);
      --thumb-grid-major:rgba(255,255,255,.04);
      --lightbox-bg:rgba(0,0,0,.85);
      --focus-overlay:rgba(20,20,20,.70);
    }
    
    body.dark-mode .btn.danger {
      border-color:#5a3030;
      background:#3a2020;
      color:#ff6b6b;
    }
    body.dark-mode .btn.danger:hover { border-color:#7a4040; }
    body.dark-mode .btn.primary {
      border-color:#2d5a8a;
      background:#1e3a5f;
    }
    body.dark-mode .btn.newTint {
      border-color:#2a5a3a;
      background:#1e3d2a;
      color:#6fbf7f;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:var(--bg);
      height:100vh;
      overflow:hidden;
    }
    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(var(--topbar-gradient-start),var(--topbar-gradient-end));
    }
    .btn{
      appearance:none;
      border:1px solid var(--border);
      background:var(--btn-bg);
      padding:7px 10px;
      border-radius:6px;
      cursor:pointer;
      font-size:13px;
      line-height:1;
      user-select:none;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      color:var(--text);
    }
    .btn:hover{ background:var(--btn-hover); border-color:var(--border); }
    .btn:active{ transform:translateY(1px); }
    .btn.danger{
      border-color:#ffb6c2;
      background:#ffe9ed;
      color:var(--danger);
    }
    .btn.danger:hover{ border-color:#ff98a7; }
    .btn.primary{
      border-color:#c9dcff;
      background:#eef5ff;
    }
    .btn.newTint{
      border-color:#bfe7c9;
      background:#eaf8ef;
      color:#1e6b2a;
    }
    .btn.fixing{
      border-color:#f0c674;
      background:#fef9e7;
      color:#8a6d3b;
      animation: pulse-fix 1s infinite;
    }
    @keyframes pulse-fix {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    body.dark-mode .btn.fixing {
      border-color:#f0c674;
      background:#4a4020;
      color:#f0c674;
    }
    .spacer{ flex:1; }
    .gapBtn{ flex:0 0 96px; width:96px; }
    .gapWide{ width:96px; }
    .search{
      flex:1;
      min-width:180px;
      max-width:650px;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid var(--border);
      font-size:14px;
      outline:none;
      background:var(--btn-bg);
      color:var(--text);
    }
    .search:focus{ border-color:var(--search-focus-border); box-shadow:0 0 0 3px var(--search-focus-shadow); }
    .status{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:34vw;
    }
    .banner{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:var(--banner-bg);
      color:var(--banner-text);
      font-size:12px;
      display:none;
    }
    .banner code{ font-family:var(--mono); }
    .main{
      display:grid;
      grid-template-columns: 320px 1fr;
      height:calc(100vh - 52px);
    }
    .left{
      border-right:1px solid var(--border);
      background:var(--panel);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      position:relative;
    }
    .list{
      overflow:auto;
      padding:6px;
    }
    .noteItem{
      border:1px solid transparent;
      border-radius:8px;
      padding:8px 10px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      gap:3px;
    }
    .noteItem:hover{
      background:var(--note-hover);
      border-color:var(--border);
    }
    .noteItem.active{
      background:var(--note-active-bg);
      border-color:var(--note-active-border);
    }
    .noteItem.folder{
      background:var(--bg);
      border-color:var(--border);
    }
    .noteItem.folder:hover{
      background:var(--note-hover);
      border-color:var(--note-active-border);
    }
    .noteItem.folder .noteTitle::before{
      content:'üìÅ ';
    }
    .folderBreadcrumb{
      padding:8px 10px;
      font-size:12px;
      color:var(--muted);
      border-bottom:1px solid var(--border);
      background:var(--bg);
      font-family:var(--mono);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .noteTitle{
      font-size:13px;
      font-weight:600;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .noteMeta{
      font-size:11px;
      color:var(--muted);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      font-family:var(--mono);
    }
    .right{
      background:var(--panel);
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .editorHeader{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    .currentTitle{
      font-size:14px;
      font-weight:700;
      font-family:var(--mono);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      flex:1;
    }
    .saveState{
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
      white-space:nowrap;
    }
    .empty{
      padding:20px;
      color:var(--muted);
      font-size:14px;
    }
    .editorWrap{
      position:relative;
      flex:1;
      overflow:hidden;
      display:flex;
      align-items:stretch;
      gap:18px;
      padding:12px 14px;
      min-width:0;
      min-height:0;
    }
    textarea{
      border:0;
      resize:none;
      padding:14px 16px;
      margin:0;
      outline:none;
      font-size:14px;
      line-height:1.55;
      font-family:var(--mono);
      flex: 1 1 50%;
      min-width: 200px;
      max-width: 50%;
      background-color:var(--editor-bg);
      color:var(--text);
      background-image:
        repeating-linear-gradient(0deg, var(--editor-grid) 0, var(--editor-grid) 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(90deg, var(--editor-grid) 0, var(--editor-grid) 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(0deg, var(--editor-grid-major) 0, var(--editor-grid-major) 1px, transparent 1px, transparent 120px),
        repeating-linear-gradient(90deg, var(--editor-grid-major) 0, var(--editor-grid-major) 1px, transparent 1px, transparent 120px);
      background-attachment: local;
    }
    .canvasWorkspace{
      flex: 1 1 50%;
      min-width: 200px;
      border:1px solid var(--border);
      border-radius:18px;
      overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.10);
      display:none;
      background-color:var(--editor-bg);
      flex-direction:column;
      position:relative;
    }
    .canvasToolbar{
      display:flex;
      gap:6px;
      padding:8px 10px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(var(--topbar-gradient-start),var(--topbar-gradient-end));
      flex-wrap:wrap;
      align-items:center;
    }
    .canvasToolbar .btn{ padding:5px 8px; font-size:12px; }
    .canvasToolbar .btn.active{ background:var(--note-active-bg); border-color:var(--note-active-border); }
    .canvasToolbar .separator{ width:1px; height:20px; background:var(--border); margin:0 4px; }
    .canvasContainer{
      flex:1;
      position:relative;
      overflow:hidden;
      background-color:var(--editor-bg);
      background-image:
        repeating-linear-gradient(0deg, var(--thumb-grid) 0, var(--thumb-grid) 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(90deg, var(--thumb-grid) 0, var(--thumb-grid) 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(0deg, var(--thumb-grid-major) 0, var(--thumb-grid-major) 1px, transparent 1px, transparent 120px),
        repeating-linear-gradient(90deg, var(--thumb-grid-major) 0, var(--thumb-grid-major) 1px, transparent 1px, transparent 120px);
      min-height: 0;
    }
    .canvasContainer canvas{ display:block; }
    .canvasContainer .canvas-container{ position:absolute !important; }
    .dropZone{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:12px;
      pointer-events:none;
      opacity:0;
      transition:opacity .2s ease;
      background:rgba(0,0,0,.03);
    }
    .dropZone.empty{ opacity:1; pointer-events:auto; }
    .dropZone.dragover{ opacity:1; background:rgba(45,90,138,.1); }
    .dropZone.dragover .dropIcon{ transform:scale(1.1); }
    .dropIcon{
      width:80px;
      height:80px;
      border:3px dashed var(--border);
      border-radius:16px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:32px;
      color:var(--muted);
      transition:transform .2s ease;
    }
    .dropText{ font-size:14px; color:var(--muted); text-align:center; }
    .dropText small{ display:block; margin-top:4px; font-size:11px; }
    .dropBrowseBtn{
      margin-top:8px;
      padding:8px 20px;
      background:var(--note-active-bg);
      border:1px solid var(--note-active-border);
      border-radius:6px;
      color:var(--text);
      cursor:pointer;
      font-size:13px;
    }
    .dropBrowseBtn:hover{ background:var(--note-active-border); }
    .canvasStatus{
      position:absolute;
      bottom:8px;
      left:8px;
      font-size:10px;
      color:var(--muted);
      font-family:var(--mono);
      background:var(--panel);
      padding:2px 6px;
      border-radius:4px;
      opacity:0.7;
    }
    /* Legacy thumb support */
    .thumb{
      flex: 1 1 0;
      min-width: 240px;
      height:100%;
      border:1px solid var(--border);
      border-radius:18px;
      overflow:hidden;
      cursor:pointer;
      box-shadow:0 10px 30px rgba(0,0,0,.10);
      display:none;
      margin-left:auto;
      background-color:var(--editor-bg);
    }
    .thumb img{
      width:100%;
      height:100%;
      display:block;
      object-fit:contain;
      background:transparent;
    }
    .lightbox{
      position:fixed;
      inset:0;
      background:var(--lightbox-bg);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:9999;
      padding:24px;
      cursor:pointer;
    }
    .lightbox img{
      max-width:92vw;
      max-height:92vh;
      object-fit:contain;
      border-radius:18px;
      background:transparent;
      cursor:pointer;
    }
    .dimOverlay{
      position:absolute;
      inset:0;
      background:var(--focus-overlay);
      opacity:0;
      pointer-events:none;
      transition:opacity .12s ease;
    }
    body.focusMode .dimOverlay{ opacity:var(--focus-strength); }
    body.focusMode .topbar .btn,
    body.focusMode .topbar .status{ opacity:.45; filter:grayscale(1); }
    body.focusMode .topbar .search{ opacity:1; filter:none; }
    body.focusMode .banner{ opacity:.55; filter:grayscale(1); }
    body.focusMode .editorHeader{ opacity:.55; filter:grayscale(1); }
    .drawModal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:10000;
      padding:18px;
    }
    .drawModal.open{ display:flex; }
    .drawDialog{
      width:min(980px, 96vw);
      height:min(92vh, 980px);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      box-shadow:0 16px 50px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
    }
    .drawTop{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(var(--topbar-gradient-start),var(--topbar-gradient-end));
      display:flex;
      align-items:center;
      gap:10px;
    }
    .drawTitle{ font-size:13px; font-weight:700; font-family:var(--mono); white-space:nowrap; }
    .drawTopBtns{ display:flex; gap:8px; flex-wrap:wrap; margin-left:auto; align-items:center; justify-content:flex-end; }
    .drawBody{ padding:12px; display:flex; flex-direction:column; gap:10px; overflow:auto; flex:1; background:var(--bg); }
    .drawCanvasWrap{
      background:var(--editor-bg);
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
      flex:1;
      min-height:420px;
    }
    #drawCanvas{ width:100%; height:100%; background:var(--editor-bg); touch-action:none; cursor:crosshair; display:block; }
    .drawHint{ font-size:12px; color:var(--muted); font-family:var(--mono); }
    .audioModal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:10000;
      padding:18px;
    }
    .audioModal.open{ display:flex; }
    .audioDialog{
      width:min(400px, 90vw);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      box-shadow:0 16px 50px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
    }
    .audioTop{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(var(--topbar-gradient-start),var(--topbar-gradient-end));
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .audioTitle{ font-size:13px; font-weight:700; font-family:var(--mono); }
    .audioBody{ padding:16px; display:flex; flex-direction:column; gap:12px; }
    .audioStatus{ font-size:13px; color:var(--muted); font-family:var(--mono); text-align:center; padding:8px; }
    .audioStatus.hasAudio{ color:#1e6b2a; }
    body.dark-mode .audioStatus.hasAudio{ color:#6fbf7f; }
    .audioBtns{ display:flex; flex-direction:column; gap:8px; }
    .audioBtns .btn{ width:100%; justify-content:center; padding:10px; }
    
    .prefsModal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:10001;
      padding:18px;
    }
    .prefsModal.open{ display:flex; }
    .prefsDialog{
      width:min(450px, 90vw);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      box-shadow:0 16px 50px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
    }
    .prefsTop{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(var(--topbar-gradient-start),var(--topbar-gradient-end));
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .prefsTitle{ font-size:14px; font-weight:700; font-family:var(--mono); color:var(--text); }
    .prefsBody{ padding:20px; display:flex; flex-direction:column; gap:20px; }
    .prefItem{ display:flex; flex-direction:column; gap:8px; }
    .prefLabel{ font-size:13px; font-weight:600; color:var(--text); }
    .prefControl{ display:flex; gap:8px; align-items:center; }
    .prefHint{ font-size:11px; color:var(--muted); }
    .themeBtn{
      flex:1;
      padding:10px 16px;
      border:1px solid var(--border);
      background:var(--btn-bg);
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
      color:var(--text);
      transition:all .15s ease;
    }
    .themeBtn:hover{ background:var(--btn-hover); }
    .themeBtn.active{
      background:var(--note-active-bg);
      border-color:var(--note-active-border);
    }
    .sliderControl{ flex-direction:column; align-items:stretch; gap:8px; }
    .slider{
      width:100%;
      height:6px;
      border-radius:3px;
      background:var(--border);
      outline:none;
      -webkit-appearance:none;
      appearance:none;
    }
    .slider::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:18px;
      height:18px;
      border-radius:50%;
      background:var(--note-active-border);
      cursor:pointer;
      border:2px solid var(--panel);
      box-shadow:0 2px 4px rgba(0,0,0,.2);
    }
    .slider::-moz-range-thumb{
      width:18px;
      height:18px;
      border-radius:50%;
      background:var(--note-active-border);
      cursor:pointer;
      border:2px solid var(--panel);
      box-shadow:0 2px 4px rgba(0,0,0,.2);
    }
    .sliderValue{ font-size:12px; color:var(--muted); font-family:var(--mono); text-align:right; }
    .exportModal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:10002;
      padding:18px;
    }
    .exportModal.open{ display:flex; }
    .exportDialog{
      width:min(500px, 90vw);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      box-shadow:0 16px 50px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
    }
    .exportTop{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(var(--topbar-gradient-start),var(--topbar-gradient-end));
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .exportTitle{ font-size:14px; font-weight:700; font-family:var(--mono); color:var(--text); }
    .exportBody{ padding:20px; display:flex; flex-direction:column; gap:12px; }
    .exportOption{
      padding:16px;
      border:1px solid var(--border);
      border-radius:10px;
      cursor:pointer;
      background:var(--btn-bg);
      transition:all .15s ease;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .exportOption:hover{
      background:var(--note-active-bg);
      border-color:var(--note-active-border);
    }
    .exportOption.disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    .exportOption.disabled:hover{
      background:var(--btn-bg);
      border-color:var(--border);
    }
    .exportOptionTitle{
      font-size:14px;
      font-weight:600;
      color:var(--text);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .exportOptionDesc{
      font-size:12px;
      color:var(--muted);
    }
    .exportCategoryTitle{
      font-size:11px;
      font-weight:600;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:0.05em;
      padding:8px 4px 6px;
      font-family:var(--mono);
    }
    .exportProgress{
      padding:16px;
      text-align:center;
      font-size:13px;
      color:var(--muted);
      font-family:var(--mono);
    }
    @keyframes gridScrollUp{
      from{ background-position: 0px 0px, 0px 0px, 0px 0px, 0px 0px; }
      to{ background-position: 0px -240px, 0px -240px, 0px -1200px, 0px -1200px; }
    }
    .asciiBoat{
      position:fixed;
      right:14px;
      bottom:14px;
      z-index:20000;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.05;
      color:rgba(0,0,0,.70);
      white-space:pre;
      margin:0;
      padding:0;
      pointer-events:none;
      text-shadow:0 1px 2px rgba(255,255,255,.65);
      will-change: transform;
    }
    @media (max-width: 860px){
      .editorWrap{ flex-direction:column; }
      textarea{ max-width:none; min-width:0; flex: 1 1 auto; }
      .thumb{ min-width:0; height:48vh; }
      .canvasWorkspace{ min-width:0; height:48vh; max-width:none; flex: 0 0 48vh; }
    }
    .ico{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:1.4em;
      height:1.4em;
      font-size:1.15em;
      line-height:1;
      vertical-align:-0.2em;
      margin-right: 0;
      user-select:none;
    }
    #refreshBtn .ico{ transform: scale( 2 ); transform-origin: center; }
    @media (prefers-reduced-motion: reduce){ .thumb{ animation:none !important; } .canvasWorkspace{ animation:none !important; } }
    @media (max-width: 820px){
      .main{ grid-template-columns: 1fr; }
      .left{ height:40vh; border-right:0; border-bottom:1px solid var(--border); }
      .status{ display:none; }
    }
    .status{ display:none !important; }
  </style>
</head>
<body>
  <div class="topbar">
    <input id="searchInput" class="search" placeholder="Trawl - - - - - <o))))><" disabled />
    <button id="openBtn" class="btn primary" aria-label="Folder"><span class="ico" aria-hidden="true">üìÅ</span></button>
    <button id="backBtn" class="btn" style="display:none;" aria-label="Back to parent folder"><span class="ico" aria-hidden="true">‚¨ÖÔ∏è</span></button>
    <button id="newFolderBtn" class="btn" disabled aria-label="New folder"><span class="ico" aria-hidden="true">üìÇ+</span></button>
    <button id="refreshBtn" class="btn" disabled aria-label="Refresh"><span class="ico" aria-hidden="true">‚ü≥</span></button>
    <div class="gapWide"></div>
    <button id="newBtn" class="btn newTint" disabled aria-label="New note"><span class="ico" aria-hidden="true">üìÑ</span></button>
    <button id="fixBtn" class="btn" disabled aria-label="Fix text" title="Fix spelling & grammar" style="display:none;"><span class="ico" aria-hidden="true">‚ú®</span></button>
    <div class="gapBtn"></div>
    <button id="drawBtn" class="btn" disabled aria-label="Draw"><span class="ico" aria-hidden="true">‚úèÔ∏è</span></button>
    <button id="attachBtn" class="btn" disabled aria-label="Attach image"><span class="ico" aria-hidden="true">üñºÔ∏è</span></button>
    <button id="audioBtn" class="btn" disabled aria-label="Audio"><span class="ico" aria-hidden="true">üîä</span></button>
    <div class="spacer"></div>
    <div id="status" class="status" style="display:none"></div>
    <button id="exportBtn" class="btn" disabled aria-label="Export"><span class="ico" aria-hidden="true">üì§</span></button>
    <div class="gapBtn"></div>
    <button id="deleteBtn" class="btn danger" disabled aria-label="Delete"><span class="ico" aria-hidden="true">üóëÔ∏è</span></button>
  </div>

  <div id="banner" class="banner"></div>

  <div class="main">
    <div class="left">
      <div id="folderBreadcrumb" class="folderBreadcrumb" style="display:none;"></div>
      <div class="list" id="list"></div>
      <div class="dimOverlay" id="dimOverlay"></div>
    </div>
    <div class="right">
      <div class="editorHeader">
        <div id="currentTitle" class="currentTitle">No note selected</div>
        <div id="saveState" class="saveState"></div>
      </div>
      <div id="empty" class="empty">Open a folder, then select or create a note.</div>
      <div id="editorWrap" class="editorWrap" style="display:none;">
        <textarea id="editor" spellcheck="false" disabled></textarea>
        <div id="canvasWorkspace" class="canvasWorkspace">
          <div class="canvasToolbar">
            <button id="canvasSelectBtn" class="btn active" title="Select/Move">üñ±Ô∏è</button>
            <button id="canvasDrawBtn" class="btn" title="Draw">‚úèÔ∏è</button>
            <div class="separator"></div>
            <button id="canvasAddImageBtn" class="btn" title="Add Image">üñºÔ∏è</button>
            <div class="separator"></div>
            <button id="canvasDeleteObjBtn" class="btn" title="Delete Selected">üóëÔ∏è</button>
            <button id="canvasClearBtn" class="btn danger" title="Clear All">Clear</button>
          </div>
          <div id="canvasContainer" class="canvasContainer">
            <canvas id="fabricCanvas"></canvas>
            <div id="dropZone" class="dropZone empty">
              <div class="dropIcon">üñºÔ∏è</div>
              <div class="dropText">
                Drag and drop images here
                <small>or paste from clipboard</small>
              </div>
              <button id="dropBrowseBtn" class="dropBrowseBtn">Browse Files</button>
            </div>
            <div id="canvasStatus" class="canvasStatus"></div>
          </div>
        </div>
        <div id="thumb" class="thumb" style="display:none !important;"><img id="thumbImg" alt="attachment" /></div>
      </div>
    </div>
  </div>

  <div id="lightbox" class="lightbox"><img id="lightboxImg" alt="attachment full size" /></div>

  <div id="drawModal" class="drawModal" aria-hidden="true">
    <div class="drawDialog" role="dialog" aria-modal="true" aria-label="Draw">
      <div class="drawTop">
        <div class="drawTitle">Draw</div>
        <div class="drawTopBtns">
          <button id="drawNewBtn" class="btn">New drawing</button>
          <button id="drawDeleteBtn" class="btn danger">Delete drawing</button>
          <button id="drawSaveBtn" class="btn primary">Save drawing</button>
          <button id="drawCloseBtn" class="btn">Close</button>
        </div>
      </div>
      <div class="drawBody">
        <div class="drawCanvasWrap">
          <canvas id="drawCanvas" width="900" height="1200"></canvas>
        </div>
        <div class="drawHint">Black pen on white. No eraser.</div>
      </div>
    </div>
  </div>

  <div id="audioModal" class="audioModal" aria-hidden="true">
    <div class="audioDialog" role="dialog" aria-modal="true" aria-label="Audio">
      <div class="audioTop">
        <div class="audioTitle">Audio Attachment</div>
        <button id="audioCloseBtn" class="btn">‚úï</button>
      </div>
      <div class="audioBody">
        <div id="audioStatus" class="audioStatus">No audio attached</div>
        <div class="audioBtns">
          <button id="audioLoadBtn" class="btn primary">Load audio file</button>
          <button id="audioPlayBtn" class="btn" disabled>Play audio</button>
          <button id="audioStopBtn" class="btn" disabled>Stop playback</button>
          <button id="audioDeleteBtn" class="btn danger" disabled>Delete audio</button>
        </div>
      </div>
    </div>
  </div>

  <audio id="audioPlayer" loop></audio>

  <div id="prefsModal" class="prefsModal" aria-hidden="true">
    <div class="prefsDialog" role="dialog" aria-modal="true" aria-label="Preferences">
      <div class="prefsTop">
        <div class="prefsTitle">Preferences</div>
        <button id="prefsCloseBtn" class="btn">‚úï</button>
      </div>
      <div class="prefsBody">
        <div class="prefItem">
          <label class="prefLabel">Theme</label>
          <div class="prefControl">
            <button id="themeLightBtn" class="themeBtn active">‚òÄÔ∏è Light</button>
            <button id="themeDarkBtn" class="themeBtn">üåô Dark</button>
          </div>
        </div>
        <div class="prefItem">
          <label class="prefLabel">Focus Mode Strength</label>
          <div class="prefControl sliderControl">
            <input type="range" id="focusStrengthSlider" min="0" max="100" value="70" class="slider">
            <span id="focusStrengthValue" class="sliderValue">70%</span>
          </div>
          <div class="prefHint">Adjust how much the UI fades when editing a note</div>
        </div>
        <div class="prefItem">
          <label class="prefLabel">Text Correction</label>
          <div class="prefControl">
            <button id="autoFixOffBtn" class="themeBtn active">Off</button>
            <button id="autoFixAutoBtn" class="themeBtn">Auto</button>
            <button id="autoFixManualBtn" class="themeBtn">Manual</button>
          </div>
          <div class="prefHint">Fix spelling and grammar (Auto: as you type, Manual: press button)</div>
        </div>
        <div class="prefItem" id="autoFixProviderItem" style="display:none;">
          <label class="prefLabel">Auto-Fix Provider</label>
          <div class="prefControl">
            <button id="providerOpenAIBtn" class="themeBtn active">OpenAI API</button>
            <button id="providerLocalBtn" class="themeBtn">Local LLM</button>
          </div>
        </div>
        <div class="prefItem" id="openAIKeyItem" style="display:none;">
          <label class="prefLabel">OpenAI API Key</label>
          <div class="prefControl">
            <input type="password" id="openAIKeyInput" class="search" style="max-width:100%;flex:1;" placeholder="sk-...">
          </div>
          <div class="prefHint">Your key is stored locally and never shared</div>
        </div>
        <div class="prefItem" id="localModelItem" style="display:none;">
          <label class="prefLabel">GGUF Model File</label>
          <div class="prefControl" style="gap:8px;">
            <input type="text" id="localModelPath" class="search" style="max-width:100%;flex:1;" placeholder="Select a .gguf model file..." readonly>
            <button id="browseModelBtn" class="btn">Browse</button>
          </div>
          <div class="prefHint">Use a local GGUF model (e.g., Llama-3.2-1B-Instruct-Q4_K_M.gguf)</div>
        </div>
        <div class="prefItem" id="localModelStatusItem" style="display:none;">
          <label class="prefLabel">Model Status</label>
          <div class="prefControl">
            <span id="localModelStatus" style="font-size:12px;color:var(--muted);">Not loaded</span>
          </div>
        </div>
        <div class="prefItem" style="border-top:1px solid var(--border);padding-top:20px;margin-top:8px;">
          <label class="prefLabel">GitHub Publishing</label>
          <div class="prefHint" style="margin-bottom:12px;">Publish notes to GitHub Pages for sharing</div>
        </div>
        <div class="prefItem">
          <label class="prefLabel">GitHub Personal Access Token</label>
          <div class="prefControl">
            <input type="password" id="githubTokenInput" class="search" style="max-width:100%;flex:1;" placeholder="ghp_...">
          </div>
          <div class="prefHint">Create at GitHub ‚Üí Settings ‚Üí Developer settings ‚Üí Personal access tokens (needs 'repo' scope)</div>
        </div>
        <div class="prefItem">
          <label class="prefLabel">GitHub Repository</label>
          <div class="prefControl">
            <input type="text" id="githubRepoInput" class="search" style="max-width:100%;flex:1;" placeholder="username/repo-name">
          </div>
          <div class="prefHint">Format: username/repository-name (e.g., myuser/my-notes)</div>
        </div>
        <div class="prefItem">
          <label class="prefLabel">My Publishing Name</label>
          <div class="prefControl">
            <input type="text" id="publishingNameInput" class="search" style="max-width:100%;flex:1;" placeholder="Your name">
          </div>
          <div class="prefHint">Optional: Adds "[Name]'s" before "Noat Boat" on exported pages (e.g., "Jim's Noat Boat")</div>
        </div>
      </div>
    </div>
  </div>

  <div id="exportModal" class="exportModal" aria-hidden="true">
    <div class="exportDialog" role="dialog" aria-modal="true" aria-label="Export">
      <div class="exportTop">
        <div class="exportTitle">Export Notes</div>
        <button id="exportCloseBtn" class="btn">‚úï</button>
      </div>
      <div class="exportBody">
        <div id="exportOptions">
          <div class="exportCategoryTitle">üìÅ Export All Notes in Folder</div>
          <div class="exportOption" id="exportPdfBtn">
            <div class="exportOptionTitle">üìÑ PDF Document</div>
            <div class="exportOptionDesc">Export all notes in the active folder as a single PDF</div>
          </div>
          <div class="exportOption" id="exportPngBtn">
            <div class="exportOptionTitle">üñºÔ∏è PNG Images</div>
            <div class="exportOptionDesc">Export all notes in the active folder as PNG images</div>
          </div>
          <div class="exportOption" id="exportEpubBtn">
            <div class="exportOptionTitle">üìö EPUB3 Book</div>
            <div class="exportOptionDesc">Export all notes in the active folder as an e-book</div>
          </div>
          <div class="exportCategoryTitle" style="margin-top:16px;">üìù Export Active Note Only</div>
          <div class="exportOption" id="exportHtmlBtn">
            <div class="exportOptionTitle">üåê HTML Website</div>
            <div class="exportOptionDesc">Export active note as a standalone HTML page</div>
          </div>
          <div class="exportOption" id="publishGithubBtn" style="border-color:var(--note-active-border);background:var(--note-active-bg);">
            <div class="exportOptionTitle">üöÄ Publish Noat to GitHub</div>
            <div class="exportOptionDesc">Publish active note to GitHub repo (requires token in Preferences)</div>
          </div>
        </div>
        <div id="exportProgress" class="exportProgress" style="display:none;">
          Exporting... <span id="exportProgressText">0%</span>
        </div>
      </div>
    </div>
  </div>

  <pre id="asciiBoat" class="asciiBoat">   .  o ..                  
     o . o o.o                
          ...oo               
            __[]__            
         __|_o_o_o\__         
         \""""""""""/         
          \. ..  . /          
     ^^^^^^^^^^^^^^^^^^^^</pre>

<script>
'use strict';

const api = window.electronAPI;

const els = {
  openBtn: document.getElementById('openBtn'),
  backBtn: document.getElementById('backBtn'),
  newFolderBtn: document.getElementById('newFolderBtn'),
  folderBreadcrumb: document.getElementById('folderBreadcrumb'),
  searchInput: document.getElementById('searchInput'),
  newBtn: document.getElementById('newBtn'),
  fixBtn: document.getElementById('fixBtn'),
  refreshBtn: document.getElementById('refreshBtn'),
  drawBtn: document.getElementById('drawBtn'),
  attachBtn: document.getElementById('attachBtn'),
  deleteBtn: document.getElementById('deleteBtn'),
  status: document.getElementById('status'),
  banner: document.getElementById('banner'),
  list: document.getElementById('list'),
  dimOverlay: document.getElementById('dimOverlay'),
  currentTitle: document.getElementById('currentTitle'),
  saveState: document.getElementById('saveState'),
  empty: document.getElementById('empty'),
  editorWrap: document.getElementById('editorWrap'),
  editor: document.getElementById('editor'),
  thumb: document.getElementById('thumb'),
  thumbImg: document.getElementById('thumbImg'),
  lightbox: document.getElementById('lightbox'),
  lightboxImg: document.getElementById('lightboxImg'),
  drawDeleteBtn: document.getElementById('drawDeleteBtn'),
  drawNewBtn: document.getElementById('drawNewBtn'),
  drawCloseBtn: document.getElementById('drawCloseBtn'),
  drawSaveBtn: document.getElementById('drawSaveBtn'),
  drawCanvas: document.getElementById('drawCanvas'),
  drawModal: document.getElementById('drawModal'),
  audioBtn: document.getElementById('audioBtn'),
  audioModal: document.getElementById('audioModal'),
  audioCloseBtn: document.getElementById('audioCloseBtn'),
  audioLoadBtn: document.getElementById('audioLoadBtn'),
  audioPlayBtn: document.getElementById('audioPlayBtn'),
  audioStopBtn: document.getElementById('audioStopBtn'),
  audioDeleteBtn: document.getElementById('audioDeleteBtn'),
  audioStatus: document.getElementById('audioStatus'),
  audioPlayer: document.getElementById('audioPlayer'),
  prefsModal: document.getElementById('prefsModal'),
  prefsCloseBtn: document.getElementById('prefsCloseBtn'),
  themeLightBtn: document.getElementById('themeLightBtn'),
  themeDarkBtn: document.getElementById('themeDarkBtn'),
  focusStrengthSlider: document.getElementById('focusStrengthSlider'),
  focusStrengthValue: document.getElementById('focusStrengthValue'),
  autoFixOffBtn: document.getElementById('autoFixOffBtn'),
  autoFixAutoBtn: document.getElementById('autoFixAutoBtn'),
  autoFixManualBtn: document.getElementById('autoFixManualBtn'),
  autoFixProviderItem: document.getElementById('autoFixProviderItem'),
  providerOpenAIBtn: document.getElementById('providerOpenAIBtn'),
  providerLocalBtn: document.getElementById('providerLocalBtn'),
  openAIKeyItem: document.getElementById('openAIKeyItem'),
  openAIKeyInput: document.getElementById('openAIKeyInput'),
  localModelItem: document.getElementById('localModelItem'),
  localModelPath: document.getElementById('localModelPath'),
  browseModelBtn: document.getElementById('browseModelBtn'),
  localModelStatusItem: document.getElementById('localModelStatusItem'),
  localModelStatus: document.getElementById('localModelStatus'),
  // Canvas workspace elements
  canvasWorkspace: document.getElementById('canvasWorkspace'),
  canvasContainer: document.getElementById('canvasContainer'),
  fabricCanvas: document.getElementById('fabricCanvas'),
  dropZone: document.getElementById('dropZone'),
  dropBrowseBtn: document.getElementById('dropBrowseBtn'),
  canvasStatus: document.getElementById('canvasStatus'),
  canvasSelectBtn: document.getElementById('canvasSelectBtn'),
  canvasDrawBtn: document.getElementById('canvasDrawBtn'),
  canvasAddImageBtn: document.getElementById('canvasAddImageBtn'),
  canvasDeleteObjBtn: document.getElementById('canvasDeleteObjBtn'),
  canvasClearBtn: document.getElementById('canvasClearBtn'),
  // Export elements
  exportBtn: document.getElementById('exportBtn'),
  exportModal: document.getElementById('exportModal'),
  exportCloseBtn: document.getElementById('exportCloseBtn'),
  exportOptions: document.getElementById('exportOptions'),
  exportPdfBtn: document.getElementById('exportPdfBtn'),
  exportPngBtn: document.getElementById('exportPngBtn'),
  exportEpubBtn: document.getElementById('exportEpubBtn'),
  exportHtmlBtn: document.getElementById('exportHtmlBtn'),
  exportProgress: document.getElementById('exportProgress'),
  exportProgressText: document.getElementById('exportProgressText'),
  // GitHub elements
  githubTokenInput: document.getElementById('githubTokenInput'),
  githubRepoInput: document.getElementById('githubRepoInput'),
  publishingNameInput: document.getElementById('publishingNameInput'),
  publishGithubBtn: document.getElementById('publishGithubBtn'),
};

let folderPath = null;
let rootFolderPath = null;  // The main folder selected by user
let subfolders = [];        // Subfolders in current directory
let notes = [];
let currentIndex = null;
let saveTimer = null;
let maxSaveTimer = null;
let isSaving = false;
let dirty = false;

// Autosave timing constants (industry standard)
const SAVE_DEBOUNCE_MS = 1000;      // Wait 1s after user stops typing
const SAVE_MAX_INTERVAL_MS = 10000; // Force save every 10s during continuous typing
let currentImageURL = null;
let listNavActive = false;
let currentListOrder = [];

// Fabric.js canvas
let fabricCanvas = null;
let canvasDrawingMode = false;
let canvasDirty = false;
let canvasSaveTimer = null;

function setFocusMode(on) {
  document.body.classList.toggle('focusMode', !!on);
}

function setListNav(on) {
  listNavActive = !!on;
}

function moveSelectionInList(delta) {
  if (!currentListOrder || currentListOrder.length === 0) return;
  let pos = currentIndex == null ? -1 : currentListOrder.indexOf(currentIndex);
  if (pos < 0) {
    pos = delta > 0 ? 0 : (currentListOrder.length - 1);
  } else {
    pos = Math.min(currentListOrder.length - 1, Math.max(0, pos + delta));
  }
  const idx = currentListOrder[pos];
  openNoteByIndex(idx, { focusEditor: false, focusMode: false, keepListNav: true }).catch(() => {});
}

function showBanner(html) {
  const msg = String(html ?? '');
  if (/state cached in an interface object/i.test(msg) || /had changed since it was read from disk/i.test(msg)) {
    return;
  }
  els.banner.innerHTML = html;
  els.banner.style.display = 'block';
}

function hideBanner() {
  els.banner.style.display = 'none';
  els.banner.innerHTML = '';
}

function setEnabled(enabled) {
  els.searchInput.disabled = !enabled;
  els.newBtn.disabled = !enabled;
  els.newFolderBtn.disabled = !enabled;
  els.refreshBtn.disabled = !enabled;
  els.exportBtn.disabled = !enabled;
}

function setEditorEnabled(enabled) {
  els.editor.disabled = !enabled;
  els.deleteBtn.disabled = !enabled;
  els.attachBtn.disabled = !enabled;
  els.drawBtn.disabled = !enabled;
  els.audioBtn.disabled = !enabled;
  els.fixBtn.disabled = !enabled;
}

function fmtDate(ts) {
  if (!ts) return '';
  const d = new Date(ts);
  return d.toLocaleString(undefined, {year:'2-digit', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});
}

function sanitizeTitleToFilename(title) {
  let t = (title || '').trim();
  if (t.toLowerCase().endsWith('.txt')) t = t.slice(0, -4);
  t = t.replace(/[\\\/:*?"<>|]/g, ' ');
  t = t.replace(/\s+/g, ' ').trim();
  if (t.length > 120) t = t.slice(0, 120).trim();
  return t;
}

function noteTitleFromName(name) {
  return name.toLowerCase().endsWith('.txt') ? name.slice(0, -4) : name;
}

function getImageExtLower(name) {
  const lower = name.toLowerCase();
  if (lower.endsWith('.png')) return 'png';
  if (lower.endsWith('.jpg')) return 'jpg';
  if (lower.endsWith('.jpeg')) return 'jpeg';
  if (lower.endsWith('.gif')) return 'gif';
  if (lower.endsWith('.webp')) return 'webp';
  return null;
}

function getAudioExtLower(name) {
  const lower = name.toLowerCase();
  if (lower.endsWith('.mp3')) return 'mp3';
  if (lower.endsWith('.wav')) return 'wav';
  if (lower.endsWith('.aiff')) return 'aiff';
  if (lower.endsWith('.aif')) return 'aif';
  if (lower.endsWith('.ogg')) return 'ogg';
  if (lower.endsWith('.m4a')) return 'm4a';
  if (lower.endsWith('.flac')) return 'flac';
  if (lower.endsWith('.wma')) return 'wma';
  return null;
}

function isAudioAttachment(name) {
  return !!getAudioExtLower(name);
}

function audioBaseKeyFromName(name) {
  const ext = getAudioExtLower(name);
  if (!ext) return null;
  return name.slice(0, -(ext.length + 1)).toLowerCase();
}

function isImageAttachment(name) {
  return !!getImageExtLower(name);
}

function attachmentBaseKeyFromName(name) {
  const lower = name.toLowerCase();
  const legacyIdx = lower.lastIndexOf('.nvimg.');
  if (legacyIdx >= 0) {
    return name.slice(0, legacyIdx).toLowerCase();
  }
  const ext = getImageExtLower(name);
  if (!ext) return null;
  return name.slice(0, -(ext.length + 1)).toLowerCase();
}

function clearThumb() {
  if (currentImageURL) {
    URL.revokeObjectURL(currentImageURL);
    currentImageURL = null;
  }
  els.thumb.style.display = 'none';
  els.thumbImg.src = '';
  els.editorWrap.classList.remove('hasImage');
  closeLightbox();
}

// --- Fabric.js Canvas Functions ---

// Canvas dimensions - set dynamically to match container
let CANVAS_WIDTH = 1200;
let CANVAS_HEIGHT = 1600;

function initFabricCanvas() {
  if (fabricCanvas) return;
  
  // Set canvas dimensions to match container exactly
  const container = els.canvasContainer;
  const rect = container.getBoundingClientRect();
  if (rect.width > 0 && rect.height > 0) {
    // Use container dimensions directly (or scaled up for higher resolution)
    const scale = 2; // 2x for crisp rendering
    CANVAS_WIDTH = Math.round(rect.width * scale);
    CANVAS_HEIGHT = Math.round(rect.height * scale);
  }
  
  fabricCanvas = new fabric.Canvas('fabricCanvas', {
    width: CANVAS_WIDTH,
    height: CANVAS_HEIGHT,
    backgroundColor: null,
    selection: true,
    preserveObjectStacking: true
  });
  
  // Set up drawing brush
  fabricCanvas.freeDrawingBrush.width = 3;
  fabricCanvas.freeDrawingBrush.color = '#000000';
  
  // Track changes
  fabricCanvas.on('object:added', onCanvasModified);
  fabricCanvas.on('object:modified', onCanvasModified);
  fabricCanvas.on('object:removed', onCanvasModified);
  fabricCanvas.on('path:created', onCanvasModified);
  
  // Resize handler
  window.addEventListener('resize', resizeFabricCanvas);
  
  // Set up drag and drop
  setupCanvasDragDrop();
  
  // Set up paste handler
  setupPasteHandler();
  
  // Initial scale
  resizeFabricCanvas();
}

function resizeFabricCanvas() {
  if (!fabricCanvas) return;
  const container = els.canvasContainer;
  const rect = container.getBoundingClientRect();
  if (rect.width <= 0 || rect.height <= 0) return;
  
  // Scale canvas to fit container exactly
  const scaleX = rect.width / CANVAS_WIDTH;
  const scaleY = rect.height / CANVAS_HEIGHT;
  const scale = Math.min(scaleX, scaleY);
  
  // Apply CSS transform to scale the canvas
  const canvasWrapper = fabricCanvas.wrapperEl;
  if (canvasWrapper) {
    canvasWrapper.style.transformOrigin = 'top left';
    canvasWrapper.style.transform = `scale(${scale})`;
    
    // Center the canvas if there's extra space
    const scaledWidth = CANVAS_WIDTH * scale;
    const scaledHeight = CANVAS_HEIGHT * scale;
    const offsetX = (rect.width - scaledWidth) / 2;
    const offsetY = (rect.height - scaledHeight) / 2;
    canvasWrapper.style.marginLeft = `${offsetX}px`;
    canvasWrapper.style.marginTop = `${offsetY}px`;
  }
}

function screenToCanvasCoords(clientX, clientY) {
  // Convert client coordinates to canvas coordinates accounting for CSS scale
  const container = els.canvasContainer;
  const rect = container.getBoundingClientRect();
  const scaleX = rect.width / CANVAS_WIDTH;
  const scaleY = rect.height / CANVAS_HEIGHT;
  const scale = Math.min(scaleX, scaleY);
  
  const scaledWidth = CANVAS_WIDTH * scale;
  const scaledHeight = CANVAS_HEIGHT * scale;
  const offsetX = (rect.width - scaledWidth) / 2;
  const offsetY = (rect.height - scaledHeight) / 2;
  
  // Convert from client coords to container-relative, then to canvas coords
  const containerX = clientX - rect.left;
  const containerY = clientY - rect.top;
  
  return {
    x: (containerX - offsetX) / scale,
    y: (containerY - offsetY) / scale
  };
}

function onCanvasModified() {
  canvasDirty = true;
  updateDropZoneVisibility();
  scheduleCanvasSave();
}

function updateDropZoneVisibility() {
  if (!fabricCanvas) return;
  const hasObjects = fabricCanvas.getObjects().length > 0;
  // Hide drop zone if there are objects OR if in drawing mode
  const shouldHide = hasObjects || canvasDrawingMode;
  els.dropZone.classList.toggle('empty', !shouldHide);
}

function updateCanvasStatus(text) {
  els.canvasStatus.textContent = text;
  setTimeout(() => {
    if (els.canvasStatus.textContent === text) {
      els.canvasStatus.textContent = '';
    }
  }, 2000);
}

function setCanvasDrawingMode(enabled) {
  canvasDrawingMode = enabled;
  if (fabricCanvas) {
    fabricCanvas.isDrawingMode = enabled;
  }
  els.canvasSelectBtn.classList.toggle('active', !enabled);
  els.canvasDrawBtn.classList.toggle('active', enabled);
  // Hide drop zone when in drawing mode so user can draw on empty canvas
  updateDropZoneVisibility();
}

function setupCanvasDragDrop() {
  const container = els.canvasContainer;
  
  container.addEventListener('dragenter', (e) => {
    e.preventDefault();
    els.dropZone.classList.add('dragover');
  });
  
  container.addEventListener('dragover', (e) => {
    e.preventDefault();
    els.dropZone.classList.add('dragover');
  });
  
  container.addEventListener('dragleave', (e) => {
    e.preventDefault();
    if (!container.contains(e.relatedTarget)) {
      els.dropZone.classList.remove('dragover');
    }
  });
  
  container.addEventListener('drop', async (e) => {
    e.preventDefault();
    els.dropZone.classList.remove('dragover');
    
    const files = e.dataTransfer.files;
    const items = e.dataTransfer.items;
    
    // Handle dropped files - use clientX/clientY for proper positioning
    if (files && files.length > 0) {
      for (const file of files) {
        if (file.type.startsWith('image/')) {
          await addImageFileToCanvas(file, e.clientX, e.clientY);
        }
      }
    }
    
    // Handle dropped URLs (images from browser)
    if (items) {
      for (const item of items) {
        if (item.type === 'text/uri-list' || item.type === 'text/plain') {
          const clientX = e.clientX;
          const clientY = e.clientY;
          item.getAsString(async (url) => {
            if (url.match(/\.(png|jpg|jpeg|gif|webp)$/i) || url.startsWith('data:image')) {
              await addImageUrlToCanvas(url, clientX, clientY);
            }
          });
        }
      }
    }
  });
}

function setupPasteHandler() {
  document.addEventListener('paste', async (e) => {
    // Only handle paste when canvas is visible and note is selected
    if (currentIndex == null || !notes[currentIndex]) return;
    if (els.canvasWorkspace.style.display === 'none') return;
    
    const items = e.clipboardData?.items;
    if (!items) return;
    
    for (const item of items) {
      if (item.type.startsWith('image/')) {
        e.preventDefault();
        const file = item.getAsFile();
        if (file) {
          await addImageFileToCanvas(file);
        }
        break;
      }
    }
  });
}

async function addImageFileToCanvas(file, x, y) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      fabric.Image.fromURL(e.target.result, (img) => {
        // Scale image to fit canvas if too large
        const maxWidth = CANVAS_WIDTH * 0.8;
        const maxHeight = CANVAS_HEIGHT * 0.8;
        
        if (img.width > maxWidth || img.height > maxHeight) {
          const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
          img.scale(scale);
        }
        
        // Position image
        if (x !== undefined && y !== undefined) {
          // Convert screen coords to canvas coords for drop position
          const canvasCoords = screenToCanvasCoords(x, y);
          img.set({ left: canvasCoords.x - (img.getScaledWidth() / 2), top: canvasCoords.y - (img.getScaledHeight() / 2) });
        } else {
          // Center image on canvas for paste/load
          img.set({ 
            left: (CANVAS_WIDTH - img.getScaledWidth()) / 2, 
            top: (CANVAS_HEIGHT - img.getScaledHeight()) / 2 
          });
        }
        
        fabricCanvas.add(img);
        fabricCanvas.setActiveObject(img);
        fabricCanvas.renderAll();
        updateCanvasStatus('Image added');
        resolve();
      });
    };
    reader.readAsDataURL(file);
  });
}

async function addImageUrlToCanvas(url, x, y) {
  return new Promise((resolve) => {
    fabric.Image.fromURL(url, (img) => {
      if (!img) {
        resolve();
        return;
      }
      
      // Scale image to fit canvas if too large
      const maxWidth = CANVAS_WIDTH * 0.8;
      const maxHeight = CANVAS_HEIGHT * 0.8;
      
      if (img.width > maxWidth || img.height > maxHeight) {
        const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
        img.scale(scale);
      }
      
      // Position image
      if (x !== undefined && y !== undefined) {
        // Convert screen coords to canvas coords for drop position
        const canvasCoords = screenToCanvasCoords(x, y);
        img.set({ left: canvasCoords.x - (img.getScaledWidth() / 2), top: canvasCoords.y - (img.getScaledHeight() / 2) });
      } else {
        // Center image on canvas for paste/load
        img.set({ 
          left: (CANVAS_WIDTH - img.getScaledWidth()) / 2, 
          top: (CANVAS_HEIGHT - img.getScaledHeight()) / 2 
        });
      }
      
      fabricCanvas.add(img);
      fabricCanvas.setActiveObject(img);
      fabricCanvas.renderAll();
      updateCanvasStatus('Image added');
      resolve();
    }, { crossOrigin: 'anonymous' });
  });
}

async function addImageFromDialog() {
  try {
    const fileData = await api.openImageDialog();
    if (!fileData) return;
    
    const dataUrl = `data:image/${fileData.ext};base64,${fileData.buffer}`;
    await addImageUrlToCanvas(dataUrl);
  } catch (err) {
    showBanner(`Could not add image. ${String(err?.message || err)}`);
  }
}

function deleteSelectedObjects() {
  if (!fabricCanvas) return;
  const activeObjects = fabricCanvas.getActiveObjects();
  if (activeObjects.length === 0) return;
  
  activeObjects.forEach(obj => fabricCanvas.remove(obj));
  fabricCanvas.discardActiveObject();
  fabricCanvas.renderAll();
  updateCanvasStatus('Deleted');
}

function clearCanvas() {
  if (!fabricCanvas) return;
  fabricCanvas.clear();
  fabricCanvas.backgroundColor = null;
  fabricCanvas.renderAll();
  updateDropZoneVisibility();
  updateCanvasStatus('Canvas cleared');
}

function scheduleCanvasSave() {
  if (canvasSaveTimer) clearTimeout(canvasSaveTimer);
  canvasSaveTimer = setTimeout(() => saveCanvasState(), 1000);
}

async function saveCanvasState() {
  if (!folderPath || currentIndex == null || !notes[currentIndex]) return;
  if (!fabricCanvas) return;
  
  const n = notes[currentIndex];
  const base = noteTitleFromName(n.name);
  const jsonPath = api.joinPath(folderPath, `${base}.canvas.json`);
  const pngPath = api.joinPath(folderPath, `${base}.canvas.png`);
  
  try {
    // Save JSON state
    const json = JSON.stringify(fabricCanvas.toJSON(['selectable', 'hasControls']));
    await api.writeCanvasJson(jsonPath, json);
    
    // Save PNG preview
    const dataUrl = fabricCanvas.toDataURL({ format: 'png', quality: 0.9 });
    await api.writeImageBuffer(pngPath, dataUrl);
    
    n.canvas = { jsonPath, pngPath };
    canvasDirty = false;
    updateCanvasStatus('Saved');
  } catch (err) {
    console.error('Failed to save canvas:', err);
  }
}

async function loadCanvasState() {
  if (!fabricCanvas) return;
  if (!folderPath || currentIndex == null || !notes[currentIndex]) {
    clearCanvas();
    return;
  }
  
  const n = notes[currentIndex];
  const base = noteTitleFromName(n.name);
  const jsonPath = api.joinPath(folderPath, `${base}.canvas.json`);
  
  try {
    const result = await api.readCanvasJson(jsonPath);
    if (result.success && result.data) {
      fabricCanvas.loadFromJSON(result.data, () => {
        fabricCanvas.renderAll();
        updateDropZoneVisibility();
        canvasDirty = false;
      });
    } else {
      // No existing canvas, check for legacy image
      if (n.image && n.image.path) {
        // Load legacy single image into canvas
        const imgResult = await api.readImageBase64(n.image.path);
        if (imgResult.success) {
          clearCanvas();
          await addImageUrlToCanvas(imgResult.dataUrl);
          canvasDirty = false;
        }
      } else {
        clearCanvas();
      }
    }
  } catch (err) {
    console.error('Failed to load canvas:', err);
    clearCanvas();
  }
}

async function deleteCanvasState() {
  if (!folderPath || currentIndex == null || !notes[currentIndex]) return;
  
  const n = notes[currentIndex];
  const base = noteTitleFromName(n.name);
  const basePath = api.joinPath(folderPath, base);
  
  try {
    await api.deleteCanvasFiles(basePath);
    n.canvas = null;
    clearCanvas();
    updateCanvasStatus('Canvas deleted');
  } catch (err) {
    console.error('Failed to delete canvas:', err);
  }
}

function showCanvasWorkspace() {
  els.canvasWorkspace.style.display = 'flex';
  if (!fabricCanvas) {
    initFabricCanvas();
  }
  setTimeout(resizeFabricCanvas, 50);
}

function hideCanvasWorkspace() {
  els.canvasWorkspace.style.display = 'none';
}

async function renderImage() {
  // Now we use canvas workspace instead of thumb
  clearThumb();
  if (currentIndex == null || !notes[currentIndex]) {
    hideCanvasWorkspace();
    return;
  }
  
  showCanvasWorkspace();
  await loadCanvasState();
}

function openLightbox() {
  if (!currentImageURL) return;
  els.lightboxImg.src = currentImageURL;
  els.lightbox.style.display = 'flex';
}

function closeLightbox() {
  els.lightbox.style.display = 'none';
  els.lightboxImg.src = '';
}

// --- drawing pad ---
let drawIsOpen = false;
let drawIsDown = false;
let drawLast = null;

function setDrawModalOpen(on) {
  drawIsOpen = !!on;
  els.drawModal.classList.toggle('open', drawIsOpen);
  els.drawModal.setAttribute('aria-hidden', drawIsOpen ? 'false' : 'true');
}

function drawCtx() {
  return els.drawCanvas.getContext('2d', { willReadFrequently: false });
}

function resizeDrawCanvas(preserve = true) {
  const wrap = els.drawCanvas.parentElement;
  if (!wrap) return;
  const rect = wrap.getBoundingClientRect();
  const cssW = Math.max(1, Math.floor(rect.width));
  const cssH = Math.max(1, Math.floor(rect.height));
  const dpr = window.devicePixelRatio || 1;
  const targetW = Math.max(1, Math.floor(cssW * dpr));
  const targetH = Math.max(1, Math.floor(cssH * dpr));
  if (els.drawCanvas.width === targetW && els.drawCanvas.height === targetH) return;

  let snapshot = null;
  if (preserve) {
    try { snapshot = els.drawCanvas.toDataURL('image/png'); } catch (_e) {}
  }
  els.drawCanvas.width = targetW;
  els.drawCanvas.height = targetH;
  clearCanvasWhite();

  if (snapshot) {
    try {
      const img = new Image();
      img.onload = () => {
        const ctx = drawCtx();
        ctx.drawImage(img, 0, 0, els.drawCanvas.width, els.drawCanvas.height);
      };
      img.src = snapshot;
    } catch (_e) {}
  }
}

function clearCanvasWhite() {
  const ctx = drawCtx();
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,els.drawCanvas.width, els.drawCanvas.height);
  ctx.restore();
}

function canvasPointFromEvent(e) {
  const rect = els.drawCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (els.drawCanvas.width / rect.width);
  const y = (e.clientY - rect.top) * (els.drawCanvas.height / rect.height);
  return {x,y};
}

function beginStroke(e) {
  drawIsDown = true;
  drawLast = canvasPointFromEvent(e);
  const ctx = drawCtx();
  ctx.strokeStyle = '#000';
  const rect = els.drawCanvas.getBoundingClientRect();
  const scale = els.drawCanvas.width / Math.max(1, rect.width);
  ctx.lineWidth = 6 * scale;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(drawLast.x, drawLast.y);
}

function moveStroke(e) {
  if (!drawIsDown) return;
  const p = canvasPointFromEvent(e);
  const ctx = drawCtx();
  ctx.lineTo(p.x, p.y);
  ctx.stroke();
  drawLast = p;
}

function endStroke() {
  drawIsDown = false;
  drawLast = null;
}

async function loadCurrentImageIntoCanvasIfAny() {
  clearCanvasWhite();
  if (currentIndex == null || !notes[currentIndex] || !notes[currentIndex].image?.path) return;

  try {
    const result = await api.readImageBase64(notes[currentIndex].image.path);
    if (!result.success) return;

    const img = new Image();
    await new Promise((res, rej) => {
      img.onload = () => res(true);
      img.onerror = rej;
      img.src = result.dataUrl;
    });

    const ctx = drawCtx();
    const cw = els.drawCanvas.width, ch = els.drawCanvas.height;
    const ir = img.width / img.height;
    const cr = cw / ch;
    let dw, dh, dx, dy;
    if (ir > cr) {
      dw = cw; dh = cw / ir; dx = 0; dy = (ch - dh) / 2;
    } else {
      dh = ch; dw = ch * ir; dy = 0; dx = (cw - dw) / 2;
    }
    ctx.drawImage(img, dx, dy, dw, dh);
  } catch (_e) {
    // ignore
  }
}

async function openDrawModal() {
  if (!folderPath) return;
  if (currentIndex == null || !notes[currentIndex]) return;
  setFocusMode(true);
  setDrawModalOpen(true);
  resizeDrawCanvas(false);
  requestAnimationFrame(() => resizeDrawCanvas(false));
  await loadCurrentImageIntoCanvasIfAny();
}

function closeDrawModal() {
  setDrawModalOpen(false);
}

async function saveDrawingAsAttachment() {
  if (!folderPath) return;
  if (currentIndex == null || !notes[currentIndex]) return;
  if (!fabricCanvas) return;

  try {
    const dataUrl = els.drawCanvas.toDataURL('image/png');
    
    // Add drawing to fabric canvas as an image
    fabric.Image.fromURL(dataUrl, (img) => {
      // Scale to fit canvas
      const maxWidth = CANVAS_WIDTH * 0.9;
      const maxHeight = CANVAS_HEIGHT * 0.9;
      
      if (img.width > maxWidth || img.height > maxHeight) {
        const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
        img.scale(scale);
      }
      
      // Center the drawing on canvas
      img.set({ 
        left: (CANVAS_WIDTH - img.getScaledWidth()) / 2, 
        top: (CANVAS_HEIGHT - img.getScaledHeight()) / 2 
      });
      fabricCanvas.add(img);
      fabricCanvas.setActiveObject(img);
      fabricCanvas.renderAll();
      updateCanvasStatus('Drawing added');
    });
    
    closeDrawModal();
  } catch (err) {
    showBanner(`Could not save drawing. ${String(err?.message || err)}`);
  }
}

async function deleteDrawingAttachment() {
  // Just close the draw modal - canvas deletion is handled via canvas toolbar
  closeDrawModal();
}

// --- Audio functions ---
let audioIsOpen = false;

function setAudioModalOpen(on) {
  audioIsOpen = !!on;
  els.audioModal.classList.toggle('open', audioIsOpen);
  els.audioModal.setAttribute('aria-hidden', audioIsOpen ? 'false' : 'true');
  if (on) updateAudioModalState();
}

function openAudioModal() {
  if (!folderPath) return;
  if (currentIndex == null || !notes[currentIndex]) return;
  setAudioModalOpen(true);
}

function closeAudioModal() {
  setAudioModalOpen(false);
}

function updateAudioModalState() {
  if (currentIndex == null || !notes[currentIndex]) {
    els.audioStatus.textContent = 'No note selected';
    els.audioStatus.classList.remove('hasAudio');
    els.audioPlayBtn.disabled = true;
    els.audioStopBtn.disabled = true;
    els.audioDeleteBtn.disabled = true;
    return;
  }
  
  const n = notes[currentIndex];
  if (n.audio) {
    els.audioStatus.textContent = `Audio: ${n.audio.name}`;
    els.audioStatus.classList.add('hasAudio');
    els.audioPlayBtn.disabled = false;
    els.audioStopBtn.disabled = false;
    els.audioDeleteBtn.disabled = false;
  } else {
    els.audioStatus.textContent = 'No audio attached';
    els.audioStatus.classList.remove('hasAudio');
    els.audioPlayBtn.disabled = true;
    els.audioStopBtn.disabled = true;
    els.audioDeleteBtn.disabled = true;
  }
}

// Track object URLs for cleanup
let currentAudioObjectUrl = null;

function stopAudio() {
  els.audioPlayer.pause();
  els.audioPlayer.currentTime = 0;
  els.audioPlayer.src = '';
  
  // Clean up object URL if any
  if (currentAudioObjectUrl) {
    URL.revokeObjectURL(currentAudioObjectUrl);
    currentAudioObjectUrl = null;
  }
}

// Convert unsupported audio to playable WAV using Web Audio API
async function convertToPlayableAudio(dataUrl) {
  console.log('[AudioConvert] Attempting to convert unsupported audio format...');
  
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Extract base64 data
    const base64Match = dataUrl.match(/^data:audio\/[^;]+;base64,(.+)$/);
    if (!base64Match) {
      throw new Error('Invalid audio data URL');
    }
    
    // Convert base64 to ArrayBuffer
    const binaryString = atob(base64Match[1]);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    // Decode audio data
    const audioBuffer = await audioContext.decodeAudioData(bytes.buffer);
    console.log(`[AudioConvert] Decoded: ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels} ch, ${audioBuffer.duration.toFixed(2)}s`);
    
    // Convert to standard PCM WAV that browsers can play
    const wavData = audioBufferToWav(audioBuffer);
    const wavBlob = new Blob([wavData], { type: 'audio/wav' });
    const wavUrl = URL.createObjectURL(wavBlob);
    
    audioContext.close();
    console.log('[AudioConvert] Conversion successful');
    
    return { success: true, url: wavUrl, isObjectUrl: true };
  } catch (e) {
    console.error('[AudioConvert] Conversion failed:', e);
    return { success: false, error: e.message };
  }
}

// Convert AudioBuffer to WAV ArrayBuffer (standard PCM format)
function audioBufferToWav(audioBuffer) {
  const numChannels = audioBuffer.numberOfChannels;
  const sampleRate = audioBuffer.sampleRate;
  const format = 1; // PCM
  const bitDepth = 16;
  
  // Interleave channels
  let interleaved;
  if (numChannels === 1) {
    interleaved = audioBuffer.getChannelData(0);
  } else {
    const left = audioBuffer.getChannelData(0);
    const right = audioBuffer.getChannelData(1);
    interleaved = new Float32Array(left.length * 2);
    for (let i = 0, j = 0; i < left.length; i++, j += 2) {
      interleaved[j] = left[i];
      interleaved[j + 1] = right[i];
    }
  }
  
  // Create WAV file
  const dataLength = interleaved.length * (bitDepth / 8);
  const buffer = new ArrayBuffer(44 + dataLength);
  const view = new DataView(buffer);
  
  // RIFF header
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataLength, true);
  writeString(view, 8, 'WAVE');
  
  // fmt chunk
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true); // chunk size
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true); // byte rate
  view.setUint16(32, numChannels * (bitDepth / 8), true); // block align
  view.setUint16(34, bitDepth, true);
  
  // data chunk
  writeString(view, 36, 'data');
  view.setUint32(40, dataLength, true);
  
  // Write PCM samples
  let offset = 44;
  for (let i = 0; i < interleaved.length; i++, offset += 2) {
    const sample = Math.max(-1, Math.min(1, interleaved[i]));
    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
  }
  
  return buffer;
  
  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
}

async function playCurrentAudio() {
  if (currentIndex == null || !notes[currentIndex] || !notes[currentIndex].audio) return;

  // Clean up previous object URL if any
  if (currentAudioObjectUrl) {
    URL.revokeObjectURL(currentAudioObjectUrl);
    currentAudioObjectUrl = null;
  }

  const audioPath = notes[currentIndex].audio.path;

  try {
    // Prefer file:// playback, with automatic FFmpeg transcode for formats Chromium can't decode (e.g. AIFF).
    const src1 = await api.getAudioPlaybackUrl(audioPath, { forceTranscode: false });
    if (!src1 || !src1.success || !src1.url) {
      showBanner(`Could not prepare audio. ${src1?.error || ''}`.trim());
      return;
    }

    els.audioPlayer.src = src1.url;

    try {
      await els.audioPlayer.play();
      return;
    } catch (playError) {
      console.log('[Audio] Playback failed:', playError?.message || playError);
    }

    // Force transcode to WAV and retry (covers platform codec gaps).
    const src2 = await api.getAudioPlaybackUrl(audioPath, { forceTranscode: true });
    if (src2 && src2.success && src2.url && src2.url !== src1.url) {
      els.audioPlayer.src = src2.url;
      await els.audioPlayer.play();
      return;
    }

    // Final fallback: data URL approach (may still fail for unsupported codecs).
    const result = await api.readAudioBase64(audioPath);
    if (!result.success) {
      showBanner('Could not read audio file.');
      return;
    }

    els.audioPlayer.src = result.dataUrl;
    await els.audioPlayer.play();
  } catch (err) {
    showBanner(`Could not play audio. ${String(err?.message || err)}`);
  }
}

async function loadAudioFile() {
  if (!folderPath) return;
  if (currentIndex == null || !notes[currentIndex]) return;
  const n = notes[currentIndex];

  try {
    const fileData = await api.openAudioDialog();
    if (!fileData) return;

    const ext = fileData.ext || 'mp3';
    const base = noteTitleFromName(n.name);
    const destName = `${base}.${ext}`;
    const destPath = api.joinPath(folderPath, destName);

    // Remove prior audio attachments for this note
    for (const oldExt of ['mp3','wav','aiff','aif','ogg','m4a','flac','wma']) {
      const oldPath = api.joinPath(folderPath, `${base}.${oldExt}`);
      if (oldPath !== destPath) {
        await api.deleteFile(oldPath);
      }
    }

    // Write the new audio file
    const base64Data = `data:audio/${ext};base64,${fileData.buffer}`;
    const result = await api.writeAudioBuffer(destPath, base64Data);
    if (!result.success) {
      showBanner(`Could not save audio. ${result.error}`);
      return;
    }

    n.audio = { name: destName, path: destPath, lastModified: result.lastModified, size: result.size };
    updateAudioModalState();
    renderList();
    
    // Auto-play the newly loaded audio
    await playCurrentAudio();
  } catch (err) {
    if (err && err.name !== 'AbortError') {
      showBanner(`Could not attach audio. ${String(err?.message || err)}`);
    }
  }
}

async function deleteAudioFile() {
  if (!folderPath) return;
  if (currentIndex == null || !notes[currentIndex]) return;
  const n = notes[currentIndex];
  const base = noteTitleFromName(n.name);

  stopAudio();

  try {
    for (const ext of ['mp3','wav','aiff','aif','ogg','m4a','flac','wma']) {
      await api.deleteFile(api.joinPath(folderPath, `${base}.${ext}`));
    }
  } catch (_e) {}

  n.audio = null;
  updateAudioModalState();
  renderList();
}

// --- Preferences functions ---
let prefsIsOpen = false;
let currentTheme = 'light';
let currentFocusStrength = 70;
let autoFixMode = 'off'; // 'off', 'auto', or 'manual'
let autoFixProvider = 'openai'; // 'openai' or 'local'
let openAIKey = '';
let localModelPath = '';
let githubToken = '';
let githubRepo = '';
let publishingName = '';
let autoFixTimer = null;
let isAutoFixing = false;
const AUTO_FIX_DEBOUNCE_MS = 1500; // Wait 1.5s after typing stops before fixing

function setPrefsModalOpen(on) {
  prefsIsOpen = !!on;
  els.prefsModal.classList.toggle('open', prefsIsOpen);
  els.prefsModal.setAttribute('aria-hidden', prefsIsOpen ? 'false' : 'true');
}

function openPrefsModal() {
  setPrefsModalOpen(true);
  updatePrefsUI();
}

function closePrefsModal() {
  setPrefsModalOpen(false);
}

// --- Export functions ---
let exportIsOpen = false;
let isExporting = false;

function setExportModalOpen(on) {
  exportIsOpen = !!on;
  els.exportModal.classList.toggle('open', exportIsOpen);
  els.exportModal.setAttribute('aria-hidden', exportIsOpen ? 'false' : 'true');
  els.exportOptions.style.display = on ? 'block' : 'none';
  els.exportProgress.style.display = 'none';
}

function openExportModal() {
  if (!folderPath || notes.length === 0) {
    api.showAlert('No notes to export. Please open a folder with notes first.');
    return;
  }
  setExportModalOpen(true);
}

function closeExportModal() {
  if (isExporting) return; // Don't close while exporting
  setExportModalOpen(false);
}

function showExportProgress(text) {
  els.exportOptions.style.display = 'none';
  els.exportProgress.style.display = 'block';
  els.exportProgressText.textContent = text;
}

function hideExportProgress() {
  els.exportOptions.style.display = 'block';
  els.exportProgress.style.display = 'none';
}

// Get CSS styles for export
function getExportStyles(isDark) {
  const bgColor = isDark ? '#1a1a1a' : '#f2f2f2';
  const panelColor = isDark ? '#252525' : '#ffffff';
  const textColor = isDark ? '#e0e0e0' : '#111';
  const mutedColor = isDark ? '#999' : '#666';
  const borderColor = isDark ? '#3a3a3a' : '#d9d9d9';
  const editorBg = isDark ? '#1e1e1e' : '#fff';
  
  return `
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: ${bgColor};
      color: ${textColor};
    }
    .note-page {
      background: ${panelColor};
      padding: 40px;
      margin: 20px auto;
      max-width: 900px;
      border: 1px solid ${borderColor};
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .note-title {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }
    .note-meta {
      font-size: 12px;
      color: ${mutedColor};
      margin-bottom: 24px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }
    .note-content {
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      background: ${editorBg};
      padding: 20px;
      border-radius: 8px;
      border: 1px solid ${borderColor};
      min-height: 200px;
    }
    .note-image {
      margin-top: 24px;
      text-align: center;
    }
    .note-image img {
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid ${borderColor};
    }
    .note-canvas {
      margin-top: 24px;
      text-align: center;
    }
    .note-canvas img {
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid ${borderColor};
    }
    .note-audio {
      margin-top: 24px;
    }
    .note-audio audio {
      width: 100%;
    }
  `;
}

// Export as PDF
async function exportToPdf() {
  if (isExporting) return;
  isExporting = true;
  showExportProgress('Preparing PDF export...');
  
  try {
    // Save current note before exporting to ensure latest content
    if (currentIndex != null && notes[currentIndex] && els.editor) {
      notes[currentIndex].content = els.editor.value;
    }
    
    // Ask user where to save
    const savePath = await api.showSaveDialog({
      title: 'Export as PDF',
      defaultPath: `${api.basename(folderPath)}-notes.pdf`,
      filters: [{ name: 'PDF', extensions: ['pdf'] }]
    });
    
    if (!savePath) {
      hideExportProgress();
      isExporting = false;
      return;
    }
    
    showExportProgress('Generating PDF...');
    
    // Collect all note data
    const notesData = [];
    for (let i = 0; i < notes.length; i++) {
      showExportProgress(`Processing note ${i + 1}/${notes.length}...`);
      const n = notes[i];
      const noteData = {
        title: n.title,
        content: n.content || '',
        lastModified: n.lastModified
      };
      
      // Get image data if exists
      if (n.canvas?.jsonPath) {
        try {
          const pngPath = n.canvas.pngPath;
          const exists = await api.fileExists(pngPath);
          if (exists) {
            const imgResult = await api.readImageBase64(pngPath);
            if (imgResult.success) {
              noteData.imageDataUrl = imgResult.dataUrl;
            }
          }
        } catch (_e) {}
      } else if (n.image?.path) {
        try {
          const imgResult = await api.readImageBase64(n.image.path);
          if (imgResult.success) {
            noteData.imageDataUrl = imgResult.dataUrl;
          }
        } catch (_e) {}
      }
      
      notesData.push(noteData);
    }
    
    showExportProgress('Writing PDF...');
    const result = await api.exportPdf(savePath, notesData, currentTheme === 'dark');
    
    if (result.success) {
      await api.showAlert(`PDF exported successfully to:\n${savePath}`);
    } else {
      showBanner(`PDF export failed: ${result.error}`);
    }
  } catch (err) {
    showBanner(`PDF export failed: ${String(err?.message || err)}`);
  } finally {
    hideExportProgress();
    isExporting = false;
    closeExportModal();
  }
}

// Export as PNG
async function exportToPng() {
  if (isExporting) return;
  isExporting = true;
  showExportProgress('Preparing PNG export...');
  
  try {
    // Save current note before exporting to ensure latest content
    if (currentIndex != null && notes[currentIndex] && els.editor) {
      notes[currentIndex].content = els.editor.value;
    }
    
    // Ask user to select folder
    const saveDir = await api.openFolderDialog();
    if (!saveDir) {
      hideExportProgress();
      isExporting = false;
      return;
    }
    
    for (let i = 0; i < notes.length; i++) {
      showExportProgress(`Exporting note ${i + 1}/${notes.length}...`);
      const n = notes[i];
      
      const noteData = {
        title: n.title,
        content: n.content || '',
        lastModified: n.lastModified
      };
      
      // Get image data if exists
      if (n.canvas?.jsonPath) {
        try {
          const pngPath = n.canvas.pngPath;
          const exists = await api.fileExists(pngPath);
          if (exists) {
            const imgResult = await api.readImageBase64(pngPath);
            if (imgResult.success) {
              noteData.imageDataUrl = imgResult.dataUrl;
            }
          }
        } catch (_e) {}
      } else if (n.image?.path) {
        try {
          const imgResult = await api.readImageBase64(n.image.path);
          if (imgResult.success) {
            noteData.imageDataUrl = imgResult.dataUrl;
          }
        } catch (_e) {}
      }
      
      const fileName = `${n.title.replace(/[<>:"/\\|?*]/g, '_')}.png`;
      const filePath = api.joinPath(saveDir, fileName);
      
      await api.exportPng(filePath, noteData, currentTheme === 'dark');
    }
    
    await api.showAlert(`PNG images exported successfully to:\n${saveDir}`);
  } catch (err) {
    showBanner(`PNG export failed: ${String(err?.message || err)}`);
  } finally {
    hideExportProgress();
    isExporting = false;
    closeExportModal();
  }
}

// Export as EPUB3
async function exportToEpub() {
  if (isExporting) return;
  isExporting = true;
  showExportProgress('Preparing EPUB export...');
  
  try {
    // Save current note before exporting to ensure latest content
    if (currentIndex != null && notes[currentIndex] && els.editor) {
      notes[currentIndex].content = els.editor.value;
    }
    
    // Ask user where to save
    const savePath = await api.showSaveDialog({
      title: 'Export as EPUB',
      defaultPath: `${api.basename(folderPath)}-notes.epub`,
      filters: [{ name: 'EPUB', extensions: ['epub'] }]
    });
    
    if (!savePath) {
      hideExportProgress();
      isExporting = false;
      return;
    }
    
    showExportProgress('Generating EPUB...');
    
    // Collect all note data
    const notesData = [];
    for (let i = 0; i < notes.length; i++) {
      showExportProgress(`Processing note ${i + 1}/${notes.length}...`);
      const n = notes[i];
      const noteData = {
        title: n.title,
        content: n.content || '',
        lastModified: n.lastModified
      };
      
      // Get image data if exists
      if (n.canvas?.jsonPath) {
        try {
          const pngPath = n.canvas.pngPath;
          const exists = await api.fileExists(pngPath);
          if (exists) {
            const imgResult = await api.readImageBase64(pngPath);
            if (imgResult.success) {
              noteData.imageDataUrl = imgResult.dataUrl;
            }
          }
        } catch (_e) {}
      } else if (n.image?.path) {
        try {
          const imgResult = await api.readImageBase64(n.image.path);
          if (imgResult.success) {
            noteData.imageDataUrl = imgResult.dataUrl;
          }
        } catch (_e) {}
      }
      
      // Note: Audio is not included in EPUB export as most e-readers don't support it
      
      notesData.push(noteData);
    }
    
    showExportProgress('Writing EPUB...');
    const bookTitle = api.basename(folderPath);
    const result = await api.exportEpub(savePath, bookTitle, notesData, currentTheme === 'dark');
    
    if (result.success) {
      await api.showAlert(`EPUB exported successfully to:\n${savePath}`);
    } else {
      showBanner(`EPUB export failed: ${result.error}`);
    }
  } catch (err) {
    showBanner(`EPUB export failed: ${String(err?.message || err)}`);
  } finally {
    hideExportProgress();
    isExporting = false;
    closeExportModal();
  }
}

// Export as HTML
async function exportToHtml() {
  if (isExporting) return;
  
  if (currentIndex == null || !notes[currentIndex]) {
    await api.showAlert('No note selected.\n\nPlease select a note to export.');
    return;
  }
  
  isExporting = true;
  showExportProgress('Preparing HTML export...');
  
  try {
    const n = notes[currentIndex];
    
    // Save current note before exporting to ensure latest content
    if (els.editor) n.content = els.editor.value;
    if (canvasDirty && fabricCanvas) await saveCanvasState();
    
    // Ask user to select destination folder
    const saveDir = await api.openFolderDialog();
    if (!saveDir) {
      hideExportProgress();
      isExporting = false;
      return;
    }
    
    showExportProgress('Collecting note data...');
    
    const noteData = {
      id: n.title,
      title: n.title,
      content: n.content || '',
      lastModified: n.lastModified
    };
    
    // Create assets folder
    const assetsDir = api.joinPath(saveDir, 'assets');
    await api.createFolder(assetsDir);
    
    // Get canvas JSON and image if exists
    if (n.canvas?.jsonPath) {
      try {
        const jsonResult = await api.readCanvasJson(n.canvas.jsonPath);
        if (jsonResult.success && jsonResult.data) {
          noteData.canvasJson = jsonResult.data;
        }
        const pngPath = n.canvas.pngPath;
        if (await api.fileExists(pngPath)) {
          const imgResult = await api.readImageBase64(pngPath);
          if (imgResult.success) {
            showExportProgress('Compressing canvas image...');
            // Convert to JPEG at 75% quality
            const jpegDataUrl = await convertImageToJpeg(imgResult.dataUrl);
            const assetPath = api.joinPath(assetsDir, 'canvas.jpg');
            await api.writeImageBuffer(assetPath, jpegDataUrl);
            noteData.canvasImage = 'assets/canvas.jpg';
          }
        }
      } catch (_e) {}
    } else if (n.image?.path) {
      try {
        const imgResult = await api.readImageBase64(n.image.path);
        if (imgResult.success) {
          showExportProgress('Compressing image...');
          // Convert to JPEG at 75% quality
          const jpegDataUrl = await convertImageToJpeg(imgResult.dataUrl);
          const assetPath = api.joinPath(assetsDir, 'image.jpg');
          await api.writeImageBuffer(assetPath, jpegDataUrl);
          noteData.image = 'assets/image.jpg';
        }
      } catch (_e) {}
    }
    
    // Get audio data if exists (convert to MP3 for export compatibility)
    if (n.audio?.path) {
      try {
        showExportProgress('Converting audio to MP3...');
        const mp3 = await api.transcodeAudioToMp3DataUrl(n.audio.path, 128);

        if (mp3 && mp3.success && mp3.dataUrl) {
          const assetPath = api.joinPath(assetsDir, 'audio.mp3');
          await api.writeAudioBuffer(assetPath, mp3.dataUrl);
          noteData.audio = 'assets/audio.mp3';
        } else {
          // Fallback: use original format
          const audioResult = await api.readAudioBase64(n.audio.path);
          if (audioResult.success) {
            const originalExt = api.extname(n.audio.name).slice(1) || 'mp3';
            const assetPath = api.joinPath(assetsDir, `audio.${originalExt}`);
            await api.writeAudioBuffer(assetPath, audioResult.dataUrl);
            noteData.audio = `assets/audio.${originalExt}`;
          }
        }
      } catch (_e) {}
    }

showExportProgress('Generating HTML page...');
    const noteHtml = generateNoteHtml(noteData, currentTheme === 'dark', publishingName);
    
    // Modify the HTML to remove the back button since this is a standalone export
    const modifiedHtml = noteHtml.replace(
      /<a href="\.\.\/index\.html" class="back-btn">Back<\/a>/,
      '<div class="back-btn" style="visibility:hidden;">Back</div>'
    );
    
    showExportProgress('Writing files...');
    const indexPath = api.joinPath(saveDir, 'index.html');
    await api.writeFile(indexPath, modifiedHtml);
    
    await api.showAlert(`HTML exported successfully to:\n${saveDir}\n\nOpen index.html to view your note.`);
    
  } catch (err) {
    showBanner(`HTML export failed: ${String(err?.message || err)}`);
    await api.showAlert(`Export failed:\n${String(err?.message || err)}`);
  } finally {
    hideExportProgress();
    isExporting = false;
    closeExportModal();
  }
}

// ============ GitHub Publishing Functions ============

// Check if a file exists on GitHub
async function githubFileExists(token, owner, repo, path) {
  try {
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    return response.ok;
  } catch (e) {
    return false;
  }
}

// Get file content and SHA from GitHub
async function githubGetFile(token, owner, repo, path) {
  try {
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    });
    if (!response.ok) return null;
    const data = await response.json();
    return {
      sha: data.sha,
      content: atob(data.content.replace(/\n/g, '')),
      encoding: data.encoding
    };
  } catch (e) {
    return null;
  }
}

// Upload or update a file on GitHub
async function githubPutFile(token, owner, repo, path, content, message, isBinary = false, sha = null) {
  try {
    const body = {
      message: message,
      content: isBinary ? content : btoa(unescape(encodeURIComponent(content)))
    };
    if (sha) body.sha = sha;
    
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `HTTP ${response.status}`);
    }
    
    return await response.json();
  } catch (e) {
    throw e;
  }
}

// Sanitize directory name for GitHub
function sanitizeDirName(name) {
  return (name || 'untitled')
    .replace(/[<>:"/\\|?*\x00-\x1f]/g, '-')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')
    .toLowerCase()
    .slice(0, 100) || 'note';
}

// Escape HTML for GitHub pages
function escapeHtmlForGithub(str) {
  return String(str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

// Generate the root index.html with animated boat
function generateRootIndexHtml(noteLinks, isDark, ownerName = '') {
  const bgColor = isDark ? '#1a1a1a' : '#f2f2f2';
  const panelColor = isDark ? '#252525' : '#ffffff';
  const textColor = isDark ? '#e0e0e0' : '#111';
  const mutedColor = isDark ? '#999' : '#666';
  const borderColor = isDark ? '#3a3a3a' : '#d9d9d9';
  const linkColor = isDark ? '#6ba3ff' : '#0066cc';
  
  // Build title with optional owner name
  const displayTitle = ownerName ? `${escapeHtmlForGithub(ownerName)}'s Noat Boat` : 'Noat Boat';
  const pageTitle = ownerName ? `${ownerName}'s Noat Boat - Published Notes` : 'Noat Boat - Published Notes';
  
  const boatArt = `   .  o ..                  
     o . o o.o                
          ...oo               
            __[]__            
         __|_o_o_o\\\\__         
         \\\\"""""""""\\"/         
          \\\\. ..  . /          
     ^^^^^^^^^^^^^^^^^^^^`;
  
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtmlForGithub(pageTitle)}</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%9B%B3%3C/text%3E%3C/svg%3E">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background-color: ${bgColor};
      background-image:
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 0, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 0, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 0, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 1px, transparent 1px, transparent 120px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 0, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 1px, transparent 1px, transparent 120px);
      color: ${textColor};
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .container { max-width: 800px; margin: 0 auto; padding: 40px 20px; flex: 1; }
    .header { text-align: center; margin-bottom: 40px; }
    .boat-container {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 14px; line-height: 1.1; white-space: pre; margin: 20px auto; color: ${mutedColor};
    }
    h1 { font-size: 28px; margin-top: 20px; font-weight: 700; }
    .subtitle { color: ${mutedColor}; font-size: 14px; margin-top: 8px; }
    .notes-list { background: ${panelColor}; border: 1px solid ${borderColor}; border-radius: 12px; overflow: hidden; }
    .note-link {
      display: block; padding: 16px 20px; text-decoration: none; color: ${textColor};
      border-bottom: 1px solid ${borderColor}; transition: background 0.15s ease;
    }
    .note-link:last-child { border-bottom: none; }
    .note-link:hover { background: ${isDark ? '#2d2d2d' : '#f8f8f8'}; }
    .note-title { font-size: 16px; font-weight: 600; color: ${linkColor}; }
    .note-meta { font-size: 12px; color: ${mutedColor}; margin-top: 4px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .footer { text-align: center; padding: 20px; font-size: 12px; color: ${mutedColor}; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <pre class="boat-container" id="asciiBoat">${boatArt}</pre>
      <h1>${displayTitle}</h1>
      <p class="subtitle">Published Notes</p>
    </div>
    <div class="notes-list" id="notesList">
      <!-- NOTE_LINKS_PLACEHOLDER -->
    </div>
  </div>
  <div class="footer">Made with Noat Boat</div>
  <script>
    (function() {
      var boatEl = document.getElementById('asciiBoat');
      if (!boatEl) return;
      if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      var base = boatEl.textContent.replace(/\\r/g, '');
      var lines = base.split('\\n');
      var wavePattern = '^_^^^-^^_^^^^-^^^-^';

      var runsByLine = lines.map(function(line) {
        var runs = [];
        var re = /\\^+/g;
        var m;
        while ((m = re.exec(line)) !== null) {
          runs.push({ start: m.index, len: m[0].length });
        }
        return runs;
      });

      var stackRow = lines.findIndex(function(l) { return l.indexOf('[]') !== -1; });
      var stackCol = stackRow >= 0 ? lines[stackRow].indexOf('[') : 0;
      var smokeRowCount = 3;
      var maxSmokeWidth = 18;
      var smokeWidth = Math.min(maxSmokeWidth, Math.max(8, stackCol));
      var smokeRows = [];
      var smokeStart = Math.max(0, Math.min(Math.max(0, stackCol - 1), stackCol - smokeWidth + 3));

      function extractRegion(line, start, len) {
        var s = String(line || '').padEnd ? String(line || '').padEnd(start + len, ' ') : String(line || '') + Array(start + len).join(' ');
        return s.slice(start, start + len);
      }

      function overlay(line, start, text) {
        var need = start + text.length;
        var padded = String(line || '').padEnd ? String(line || '').padEnd(need, ' ') : String(line || '') + Array(need).join(' ');
        var chars = padded.split('');
        for (var i = 0; i < text.length; i++) chars[start + i] = text[i];
        return chars.join('');
      }

      function clearFromCol(line, col) {
        var chars = String(line || '').split('');
        for (var i = col; i < chars.length; i++) {
          if (chars[i] === 'o' || chars[i] === '.') chars[i] = ' ';
        }
        return chars.join('');
      }

      var seed = 123456789;
      function rand() {
        seed = (seed * 1664525 + 1013904223) >>> 0;
        return seed / 4294967296;
      }

      function driftAndFadeRow(row) {
        var shifted = row.slice(1) + ' ';
        var chars = shifted.split('');
        for (var i = 0; i < chars.length; i++) {
          var c = chars[i];
          if (c === 'o' && rand() < 0.30) chars[i] = '.';
          else if (c === '.' && rand() < 0.22) chars[i] = ' ';
        }
        return chars.join('');
      }

      function makeSeedRow() {
        var chars = Array(smokeWidth).fill ? Array(smokeWidth).fill(' ') : [];
        if (!chars.fill) for (var i = 0; i < smokeWidth; i++) chars.push(' ');
        var origin = Math.max(0, smokeWidth - 3);
        var count = 3 + Math.floor(rand() * 4);
        for (var i = 0; i < count; i++) {
          var driftLeft = Math.floor(rand() * 10);
          var pos = Math.max(0, origin - driftLeft);
          var far = (origin - pos) >= 5;
          chars[pos] = rand() < (far ? 0.20 : 0.55) ? 'o' : '.';
        }
        if (rand() < 0.55) {
          var pos = Math.max(0, origin - (8 + Math.floor(rand() * 8)));
          if (pos < smokeWidth && chars[pos] === ' ') chars[pos] = '.';
        }
        if (rand() < 0.30) {
          var pos = Math.max(0, origin - (10 + Math.floor(rand() * 6)));
          if (pos < smokeWidth && chars[pos] === ' ') chars[pos] = '.';
        }
        return chars.join('');
      }

      var smokeBuf = [];
      if (stackRow >= 0) {
        for (var r = Math.max(0, stackRow - smokeRowCount); r < stackRow; r++) {
          smokeRows.push(r);
        }
        smokeBuf = smokeRows.map(function(r) { return extractRegion(lines[r], smokeStart, smokeWidth); });

        for (var j = 0; j < smokeRows.length; j++) {
          var row = smokeRows[j];
          var line = String(lines[row] || '');
          var chars = smokeBuf[j].split('');
          var insertPos = smokeWidth - 1;
          for (var c = stackCol; c < line.length; c++) {
            var ch = line[c];
            if (ch === 'o' || ch === '.') {
              while (insertPos >= 0 && chars[insertPos] === 'o') insertPos--;
              if (insertPos >= 0) { chars[insertPos] = ch; insertPos--; }
            }
          }
          smokeBuf[j] = chars.join('');
        }
      }

      var offset = 0;
      var smokeTick = 0;
      var intervalMs = 140;

      setInterval(function() {
        offset = (offset + 1) % wavePattern.length;
        smokeTick++;

        if (smokeRows.length) {
          smokeBuf = smokeBuf.map(driftAndFadeRow);
          if (smokeTick % 2 === 0) {
            smokeBuf = smokeBuf.slice(1).concat([makeSeedRow()]);
          }
        }

        var out = lines.map(function(line, i) {
          var runs = runsByLine[i];
          if (!runs || runs.length === 0) return line;
          var chars = line.split('');
          for (var j = 0; j < runs.length; j++) {
            var r = runs[j];
            var need = r.len;
            var repeatCount = Math.ceil((need + offset) / wavePattern.length) + 2;
            var seq = '';
            for (var x = 0; x < repeatCount; x++) seq += wavePattern;
            seq = seq.slice(offset, offset + need);
            for (var k = 0; k < need; k++) chars[r.start + k] = seq[k];
          }
          return chars.join('');
        });

        if (smokeRows.length && stackCol > 0) {
          for (var j = 0; j < smokeRows.length; j++) {
            var row = smokeRows[j];
            out[row] = clearFromCol(out[row], stackCol);
          }
        }

        if (smokeRows.length) {
          for (var j = 0; j < smokeRows.length; j++) {
            var row = smokeRows[j];
            out[row] = overlay(out[row], smokeStart, smokeBuf[j]);
          }
        }

        boatEl.textContent = out.join('\\n');
      }, intervalMs);
    })();
  <\/script>
</body>
</html>`;
}

// Add a note link to the root index HTML
function addNoteToRootIndex(html, noteTitle, noteDirName, lastModified) {
  const dateStr = lastModified ? new Date(lastModified).toLocaleDateString() : '';
  const newLink = `<a href="./${noteDirName}/index.html" class="note-link">
        <div class="note-title">${escapeHtmlForGithub(noteTitle)}</div>
        <div class="note-meta">${dateStr}</div>
      </a>`;
  
  // Check if this note already exists in the index (update it in place)
  const existingLinkRegex = new RegExp(`<a href="\\.\\/${noteDirName}\\/index\\.html"[^>]*class="note-link"[\\s\\S]*?<\\/a>`, 'g');
  if (existingLinkRegex.test(html)) {
    return html.replace(existingLinkRegex, newLink);
  }
  
  // Insert at the top (right after the opening of notes-list div)
  // Look for the notes-list div and insert after its opening tag
  const notesListMatch = html.match(/<div class="notes-list" id="notesList">\s*/);
  if (notesListMatch) {
    const insertPos = notesListMatch.index + notesListMatch[0].length;
    return html.slice(0, insertPos) + '\n      ' + newLink + html.slice(insertPos);
  }
  
  // Fallback: Try placeholder (insert right after placeholder for backwards compatibility)
  if (html.includes('<!-- NOTE_LINKS_PLACEHOLDER -->')) {
    return html.replace('<!-- NOTE_LINKS_PLACEHOLDER -->', newLink + '\n      <!-- NOTE_LINKS_PLACEHOLDER -->');
  }
  
  // Last resort: insert before </body>
  const bodyEnd = html.lastIndexOf('</body>');
  if (bodyEnd > 0) {
    return html.slice(0, bodyEnd) + '<div class="notes-list">' + newLink + '</div>\n' + html.slice(bodyEnd);
  }
  
  return html;
}

// Generate interactive note HTML page
function generateNoteHtml(noteData, isDark, ownerName = '') {
  const bgColor = isDark ? '#1a1a1a' : '#f2f2f2';
  const panelColor = isDark ? '#252525' : '#ffffff';
  const textColor = isDark ? '#e0e0e0' : '#111';
  const mutedColor = isDark ? '#999' : '#666';
  const borderColor = isDark ? '#3a3a3a' : '#d9d9d9';
  const editorBg = isDark ? '#1e1e1e' : '#fff';
  const activeBg = isDark ? '#1e3a5f' : '#eef5ff';
  const activeBorder = isDark ? '#2d5a8a' : '#c9dcff';
  
  // Build the Noat Boat branding with optional owner name
  const noatBoatTitle = ownerName ? `${escapeHtmlForGithub(ownerName)}'s Noat Boat` : 'Noat Boat';
  
  const canvasJsonStr = noteData.canvasJson ? JSON.stringify(noteData.canvasJson).replace(/</g, '\\u003c').replace(/>/g, '\\u003e') : 'null';
  const hasCanvas = !!(noteData.canvasJson || noteData.canvasImage || noteData.image);
  const hasAudio = !!noteData.audio;
  const noteIdStr = JSON.stringify(noteData.id || noteData.title);
  const canvasImageStr = noteData.canvasImage ? JSON.stringify(noteData.canvasImage) : 'null';
  const fallbackImageStr = noteData.image ? JSON.stringify(noteData.image) : 'null';
  
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtmlForGithub(noteData.title)} - ${noatBoatTitle}</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"><\/script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: system-ui, -apple-system, sans-serif; 
      background-color: ${bgColor}; 
      background-image:
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 0, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 0, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 0, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 1px, transparent 1px, transparent 120px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 0, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 1px, transparent 1px, transparent 120px);
      color: ${textColor}; 
      height: 100vh; 
      display: flex; 
      flex-direction: column; 
    }
    .topbar { display: flex; align-items: center; padding: 10px 14px; border-bottom: 1px solid ${borderColor}; background: ${panelColor}; gap: 12px; }
    .back-btn { padding: 6px 12px; border: 1px solid ${borderColor}; background: ${panelColor}; border-radius: 6px; cursor: pointer; font-size: 13px; color: ${textColor}; text-decoration: none; }
    .title { font-size: 16px; font-weight: 700; font-family: monospace; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .save-status { font-size: 12px; color: ${mutedColor}; font-family: monospace; }
    .main { display: flex; flex: 1; overflow: hidden; gap: 16px; padding: 14px; min-height: 0; }
    .editor-pane { flex: 1; display: flex; flex-direction: column; min-width: 200px; min-height: 0; }
    textarea { 
      flex: 1; 
      border: 1px solid ${borderColor}; 
      border-radius: 12px; 
      resize: none; 
      padding: 14px; 
      font-size: 14px; 
      line-height: 1.55; 
      font-family: monospace; 
      background-color: ${editorBg}; 
      background-image:
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 0, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 0, ${isDark ? 'rgba(255,255,255,.03)' : 'rgba(0,0,0,.025)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 0, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 1px, transparent 1px, transparent 120px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 0, ${isDark ? 'rgba(255,255,255,.06)' : 'rgba(0,0,0,.04)'} 1px, transparent 1px, transparent 120px);
      background-attachment: local;
      color: ${textColor}; 
      outline: none; 
    }
    .canvas-pane { flex: 1; display: ${hasCanvas ? 'flex' : 'none'}; flex-direction: column; min-width: 200px; min-height: 0; border: 1px solid ${borderColor}; border-radius: 12px; overflow: hidden; background: ${editorBg}; }
    .canvas-toolbar { display: flex; gap: 6px; padding: 8px 10px; border-bottom: 1px solid ${borderColor}; background: ${panelColor}; flex-shrink: 0; }
    .btn { padding: 5px 10px; border: 1px solid ${borderColor}; background: ${panelColor}; border-radius: 6px; cursor: pointer; font-size: 12px; color: ${textColor}; }
    .btn.active { background: ${activeBg}; border-color: ${activeBorder}; }
    #canvasContainer { 
      flex: 1; 
      position: relative; 
      overflow: hidden; 
      min-height: 0;
      background-color: ${editorBg};
      background-image:
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.02)' : 'rgba(0,0,0,.02)'} 0, ${isDark ? 'rgba(255,255,255,.02)' : 'rgba(0,0,0,.02)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.02)' : 'rgba(0,0,0,.02)'} 0, ${isDark ? 'rgba(255,255,255,.02)' : 'rgba(0,0,0,.02)'} 1px, transparent 1px, transparent 24px),
        repeating-linear-gradient(0deg, ${isDark ? 'rgba(255,255,255,.04)' : 'rgba(0,0,0,.035)'} 0, ${isDark ? 'rgba(255,255,255,.04)' : 'rgba(0,0,0,.035)'} 1px, transparent 1px, transparent 120px),
        repeating-linear-gradient(90deg, ${isDark ? 'rgba(255,255,255,.04)' : 'rgba(0,0,0,.035)'} 0, ${isDark ? 'rgba(255,255,255,.04)' : 'rgba(0,0,0,.035)'} 1px, transparent 1px, transparent 120px);
    }
    #canvasContainer canvas { display: block; }
    #canvasContainer .canvas-container { position: absolute !important; }
    .audio-player { padding: 10px; border-top: 1px solid ${borderColor}; display: ${hasAudio ? 'block' : 'none'}; flex-shrink: 0; }
    .audio-player audio { width: 100%; }
    @media (max-width: 768px) { .main { flex-direction: column; } .editor-pane, .canvas-pane { flex: none; height: 45vh; } }
  </style>
</head>
<body>
  <div class="topbar">
    <a href="../index.html" class="back-btn">Back</a>
    <div class="title">${escapeHtmlForGithub(noteData.title)}</div>
    <div class="save-status" id="saveStatus"></div>
  </div>
  <div class="main">
    <div class="editor-pane">
      <textarea id="editor" spellcheck="false">${escapeHtmlForGithub(noteData.content || '')}</textarea>
    </div>
    <div class="canvas-pane" id="canvasPane">
      <div class="canvas-toolbar">
        <button id="selectBtn" class="btn active">Select</button>
        <button id="drawBtn" class="btn">Draw</button>
      </div>
      <div id="canvasContainer">
        <canvas id="fabricCanvas"></canvas>
      </div>
      <div class="audio-player"><audio controls loop src="${noteData.audio || ''}"></audio></div>
    </div>
  </div>
  <script>
    (function() {
      var STORAGE_KEY = 'noatboat_' + ${noteIdStr};
      var canvasJson = ${canvasJsonStr};
      var canvasImage = ${canvasImageStr};
      var fallbackImage = ${fallbackImageStr};
      var fabricCanvas = null, saveTimer = null;
      
      var editor = document.getElementById('editor');
      var saveStatus = document.getElementById('saveStatus');
      
      try { var saved = localStorage.getItem(STORAGE_KEY); if (saved) { var data = JSON.parse(saved); if (data.content) editor.value = data.content; } } catch(e){}
      
      function scheduleSave() {
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(function() {
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ content: editor.value })); saveStatus.textContent = 'saved'; } catch(e){}
        }, 1000);
      }
      editor.addEventListener('input', function() { saveStatus.textContent = 'modified'; scheduleSave(); });
      
      function fitCanvasViewport(padding) {
        padding = padding || 24;
        if (!fabricCanvas) return;

        var objects = fabricCanvas.getObjects();
        if (!objects || objects.length === 0) {
          fabricCanvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
          fabricCanvas.requestRenderAll();
          return;
        }

        // Compute overall bounds in canvas coords
        var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (var i = 0; i < objects.length; i++) {
          var r = objects[i].getBoundingRect(true, true);
          minX = Math.min(minX, r.left);
          minY = Math.min(minY, r.top);
          maxX = Math.max(maxX, r.left + r.width);
          maxY = Math.max(maxY, r.top + r.height);
        }

        var contentW = Math.max(1, maxX - minX);
        var contentH = Math.max(1, maxY - minY);

        var cw = fabricCanvas.getWidth();
        var ch = fabricCanvas.getHeight();

        var availW = Math.max(1, cw - padding * 2);
        var availH = Math.max(1, ch - padding * 2);

        var scale = Math.min(availW / contentW, availH / contentH);

        // Center content
        var contentCx = minX + contentW / 2;
        var contentCy = minY + contentH / 2;
        var tx = (cw / 2) - (contentCx * scale);
        var ty = (ch / 2) - (contentCy * scale);

        fabricCanvas.setViewportTransform([scale, 0, 0, scale, tx, ty]);
        fabricCanvas.requestRenderAll();
      }
      
      function initCanvas() {
        var container = document.getElementById('canvasContainer');
        var rect = container.getBoundingClientRect();
        
        var width = Math.max(Math.floor(rect.width), 400);
        var height = Math.max(Math.floor(rect.height), 300);
        
        fabricCanvas = new fabric.Canvas('fabricCanvas', {
          width: width,
          height: height,
          backgroundColor: null,
          selection: true,
          preserveObjectStacking: true
        });
        
        fabricCanvas.freeDrawingBrush.width = 3;
        fabricCanvas.freeDrawingBrush.color = '#000000';
        
        if (canvasJson) {
          fabricCanvas.loadFromJSON(canvasJson, function() {
            fitCanvasViewport();
            fabricCanvas.renderAll();
          });
        } else if (canvasImage || fallbackImage) {
          fabric.Image.fromURL(canvasImage || fallbackImage, function(img) {
            if (!img) return;
            
            var canvasWidth = fabricCanvas.width;
            var canvasHeight = fabricCanvas.height;
            
            // Scale image to fit within canvas with padding
            var maxWidth = canvasWidth * 0.9;
            var maxHeight = canvasHeight * 0.9;
            
            var scale = 1;
            if (img.width > maxWidth || img.height > maxHeight) {
              scale = Math.min(maxWidth / img.width, maxHeight / img.height);
            }
            
            img.scale(scale);
            img.set({
              left: (canvasWidth - img.getScaledWidth()) / 2,
              top: (canvasHeight - img.getScaledHeight()) / 2,
              selectable: true
            });
            
            fabricCanvas.add(img);
            fabricCanvas.renderAll();
          }, null, { crossOrigin: 'anonymous' });
        }
      }
      
      document.getElementById('selectBtn').onclick = function() { 
        if(fabricCanvas) { 
          fabricCanvas.isDrawingMode = false; 
          this.classList.add('active'); 
          document.getElementById('drawBtn').classList.remove('active'); 
        } 
      };
      document.getElementById('drawBtn').onclick = function() { 
        if(fabricCanvas) { 
          fabricCanvas.isDrawingMode = true; 
          this.classList.add('active'); 
          document.getElementById('selectBtn').classList.remove('active'); 
        } 
      };
      
      setTimeout(initCanvas, 150);
      
      window.addEventListener('resize', function() {
        if (!fabricCanvas) return;
        var container = document.getElementById('canvasContainer');
        var rect = container.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          fabricCanvas.setDimensions({ width: rect.width, height: rect.height });
          fitCanvasViewport();
        }
      });
    })();
  <\/script>
</body>
</html>`;
}

// Main function to publish current note to GitHub

// Helper function to convert image data URL to JPEG at 75% quality (browser-based)
async function convertImageToJpeg(dataUrl) {
  return new Promise((resolve) => {
    // Skip if not an image or already a JPEG
    if (!dataUrl || !dataUrl.startsWith('data:image/')) {
      resolve(dataUrl);
      return;
    }
    
    const img = new Image();
    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        
        // Fill with white background (for transparency)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw the image
        ctx.drawImage(img, 0, 0);
        
        // Convert to JPEG at 75% quality
        const jpegDataUrl = canvas.toDataURL('image/jpeg', 0.75);
        resolve(jpegDataUrl);
      } catch (e) {
        console.error('Failed to convert image to JPEG:', e);
        resolve(dataUrl); // Return original on error
      }
    };
    img.onerror = () => {
      console.error('Failed to load image for JPEG conversion');
      resolve(dataUrl); // Return original on error
    };
    img.src = dataUrl;
  });
}

// Helper function to compress audio to MP3 at 128kbps (browser-based using lamejs from CDN)
// Only compresses uncompressed formats: wav, aif, aiff
// Returns original for already compressed formats: mp3, aac, m4a, opus, ogg, flac, wma
async function compressAudioToMp3(dataUrl, originalExt) {
  const ext = (originalExt || '').toLowerCase().replace('.', '');
  console.log(`[AudioCompress] Called with ext: "${ext}"`);
  
  // Check if lamejs is available (loaded from CDN)
  if (typeof lamejs === 'undefined' || !lamejs.Mp3Encoder) {
    console.log('[AudioCompress] lamejs not available, returning audio as-is');
    return { success: true, dataUrl, ext, wasCompressed: false };
  }
  
  // List of already compressed formats - return as-is
  const compressedFormats = ['mp3', 'aac', 'm4a', 'opus', 'ogg', 'flac', 'wma', 'mpeg'];
  if (compressedFormats.includes(ext)) {
    console.log(`[AudioCompress] Format "${ext}" is already compressed, skipping`);
    return { success: true, dataUrl, ext, wasCompressed: false };
  }
  
  // List of uncompressed formats we can convert
  const uncompressedFormats = ['wav', 'aif', 'aiff', 'pcm', 'raw'];
  if (!uncompressedFormats.includes(ext)) {
    console.log(`[AudioCompress] Unknown format "${ext}", returning as-is`);
    return { success: true, dataUrl, ext, wasCompressed: false };
  }
  
  console.log(`[AudioCompress] Compressing ${ext} to MP3 at 128kbps...`);
  
  try {
    // Decode audio using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Extract base64 data
    const base64Match = dataUrl.match(/^data:audio\/[^;]+;base64,(.+)$/);
    if (!base64Match) {
      return { success: false, error: 'Invalid audio data URL format' };
    }
    
    // Convert base64 to ArrayBuffer
    const binaryString = atob(base64Match[1]);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    // Decode the audio
    const audioBuffer = await audioContext.decodeAudioData(bytes.buffer);
    console.log(`[AudioCompress] Decoded: ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels} channels, ${audioBuffer.duration.toFixed(2)}s`);
    
    const sampleRate = audioBuffer.sampleRate;
    const numChannels = Math.min(audioBuffer.numberOfChannels, 2); // Max 2 channels for MP3
    
    // Get audio data as Float32Array and convert to Int16
    const leftChannel = audioBuffer.getChannelData(0);
    const rightChannel = numChannels > 1 ? audioBuffer.getChannelData(1) : leftChannel;
    
    // Convert Float32 (-1 to 1) to Int16 (-32768 to 32767)
    const leftInt16 = new Int16Array(leftChannel.length);
    const rightInt16 = new Int16Array(rightChannel.length);
    for (let i = 0; i < leftChannel.length; i++) {
      leftInt16[i] = Math.max(-32768, Math.min(32767, Math.round(leftChannel[i] * 32767)));
      rightInt16[i] = Math.max(-32768, Math.min(32767, Math.round(rightChannel[i] * 32767)));
    }
    
    // Encode to MP3
    const mp3encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, 128);
    const mp3Data = [];
    
    const sampleBlockSize = 1152; // lamejs requires this block size
    for (let i = 0; i < leftInt16.length; i += sampleBlockSize) {
      const leftChunk = leftInt16.subarray(i, Math.min(i + sampleBlockSize, leftInt16.length));
      const rightChunk = rightInt16.subarray(i, Math.min(i + sampleBlockSize, rightInt16.length));
      
      let mp3buf;
      if (numChannels === 1) {
        mp3buf = mp3encoder.encodeBuffer(leftChunk);
      } else {
        mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
      }
      
      if (mp3buf.length > 0) {
        mp3Data.push(mp3buf);
      }
    }
    
    // Flush remaining data
    const mp3End = mp3encoder.flush();
    if (mp3End.length > 0) {
      mp3Data.push(mp3End);
    }
    
    // Combine all MP3 chunks
    const totalLength = mp3Data.reduce((sum, buf) => sum + buf.length, 0);
    const mp3Buffer = new Uint8Array(totalLength);
    let offset = 0;
    for (const buf of mp3Data) {
      mp3Buffer.set(buf, offset);
      offset += buf.length;
    }
    
    // Convert to base64 data URL
    let binary = '';
    for (let i = 0; i < mp3Buffer.length; i++) {
      binary += String.fromCharCode(mp3Buffer[i]);
    }
    const mp3Base64 = btoa(binary);
    const mp3DataUrl = `data:audio/mpeg;base64,${mp3Base64}`;
    
    const originalSize = bytes.length;
    const compressedSize = mp3Buffer.length;
    console.log(`[AudioCompress] Compressed: ${originalSize} bytes -> ${compressedSize} bytes (${Math.round(compressedSize / originalSize * 100)}%)`);
    
    // Close audio context
    audioContext.close();
    
    return { success: true, dataUrl: mp3DataUrl, ext: 'mp3', wasCompressed: true };
  } catch (e) {
    console.error('[AudioCompress] Error:', e);
    return { success: false, error: e.message };
  }
}

async function publishToGithub() {
  if (isExporting) return;
  
  if (!githubToken) {
    await api.showAlert('GitHub Personal Access Token not set.\n\nPlease set it in Preferences.');
    return;
  }
  
  if (!githubRepo || !githubRepo.includes('/')) {
    await api.showAlert('GitHub Repository not set or invalid format.\n\nPlease set it in Preferences as "username/repo-name"');
    return;
  }
  
  if (currentIndex == null || !notes[currentIndex]) {
    await api.showAlert('No note selected.\n\nPlease select a note to publish.');
    return;
  }
  
  isExporting = true;
  showExportProgress('Preparing to publish...');
  
  try {
    const [owner, repo] = githubRepo.split('/');
    const n = notes[currentIndex];
    
    if (els.editor) n.content = els.editor.value;
    if (canvasDirty && fabricCanvas) await saveCanvasState();
    
    const noteDirName = sanitizeDirName(n.title);
    showExportProgress('Collecting note data...');
    
    const noteData = { id: noteDirName, title: n.title, content: n.content || '', lastModified: n.lastModified };
    const filesToUpload = [];
    
    if (n.canvas?.jsonPath) {
      try {
        const jsonResult = await api.readCanvasJson(n.canvas.jsonPath);
        if (jsonResult.success && jsonResult.data) noteData.canvasJson = jsonResult.data;
        const pngPath = n.canvas.pngPath;
        if (await api.fileExists(pngPath)) {
          const imgResult = await api.readImageBase64(pngPath);
          if (imgResult.success) {
            // Convert to JPEG for smaller file size
            showExportProgress('Compressing canvas image...');
            const jpegDataUrl = await convertImageToJpeg(imgResult.dataUrl);
            noteData.canvasImage = 'canvas.jpg';
            filesToUpload.push({ path: `${noteDirName}/canvas.jpg`, content: jpegDataUrl.split(',')[1], isBinary: true });
          }
        }
      } catch (_e) {}
    } else if (n.image?.path) {
      try {
        const imgResult = await api.readImageBase64(n.image.path);
        if (imgResult.success) {
          // Convert to JPEG for smaller file size
          showExportProgress('Compressing image...');
          const jpegDataUrl = await convertImageToJpeg(imgResult.dataUrl);
          noteData.image = 'image.jpg';
          filesToUpload.push({ path: `${noteDirName}/image.jpg`, content: jpegDataUrl.split(',')[1], isBinary: true });
        }
      } catch (_e) {}
    }
    
    if (n.audio?.path) {
      try {
        showExportProgress('Converting audio to MP3...');
        const mp3 = await api.transcodeAudioToMp3DataUrl(n.audio.path, 128);

        if (mp3 && mp3.success && mp3.dataUrl) {
          noteData.audio = 'audio.mp3';
          filesToUpload.push({ path: `${noteDirName}/audio.mp3`, content: mp3.dataUrl.split(',')[1], isBinary: true });
        } else {
          // Fallback: use original format
          const audioResult = await api.readAudioBase64(n.audio.path);
          if (audioResult.success) {
            const originalExt = api.extname(n.audio.name).slice(1) || 'mp3';
            noteData.audio = `audio.${originalExt}`;
            filesToUpload.push({ path: `${noteDirName}/audio.${originalExt}`, content: audioResult.dataUrl.split(',')[1], isBinary: true });
          }
        }
      } catch (_e) {}
    }

showExportProgress('Generating note page...');
    const noteHtml = generateNoteHtml(noteData, currentTheme === 'dark', publishingName);
    filesToUpload.unshift({ path: `${noteDirName}/index.html`, content: noteHtml, isBinary: false });
    
    for (let i = 0; i < filesToUpload.length; i++) {
      const file = filesToUpload[i];
      showExportProgress(`Uploading ${i + 1}/${filesToUpload.length}: ${file.path}...`);
      let sha = null;
      const existing = await githubGetFile(githubToken, owner, repo, file.path);
      if (existing) sha = existing.sha;
      await githubPutFile(githubToken, owner, repo, file.path, file.content, `Update ${file.path}`, file.isBinary, sha);
    }
    
    showExportProgress('Updating site index...');
    let rootHtml;
    const existingRoot = await githubGetFile(githubToken, owner, repo, 'index.html');
    if (existingRoot && existingRoot.content) {
      rootHtml = addNoteToRootIndex(existingRoot.content, n.title, noteDirName, n.lastModified);
    } else {
      rootHtml = generateRootIndexHtml([], currentTheme === 'dark', publishingName);
      rootHtml = addNoteToRootIndex(rootHtml, n.title, noteDirName, n.lastModified);
    }
    await githubPutFile(githubToken, owner, repo, 'index.html', rootHtml, 'Update site index', false, existingRoot?.sha || null);
    
    const pagesUrl = `https://${owner}.github.io/${repo}/${noteDirName}/`;
    await api.showAlert(`Published successfully!\n\nYour note is available at:\n${pagesUrl}\n\n(Enable GitHub Pages in repo settings if not already done)`);
    
  } catch (err) {
    showBanner(`GitHub publish failed: ${String(err?.message || err)}`);
    await api.showAlert(`Publish failed:\n${String(err?.message || err)}`);
  } finally {
    hideExportProgress();
    isExporting = false;
    closeExportModal();
  }
}

function updatePrefsUI() {
  els.themeLightBtn.classList.toggle('active', currentTheme === 'light');
  els.themeDarkBtn.classList.toggle('active', currentTheme === 'dark');
  els.focusStrengthSlider.value = currentFocusStrength;
  els.focusStrengthValue.textContent = `${currentFocusStrength}%`;
  els.autoFixOffBtn.classList.toggle('active', autoFixMode === 'off');
  els.autoFixAutoBtn.classList.toggle('active', autoFixMode === 'auto');
  els.autoFixManualBtn.classList.toggle('active', autoFixMode === 'manual');
  
  // Show provider selection when auto-fix is enabled (auto or manual mode)
  const fixEnabled = autoFixMode !== 'off';
  els.autoFixProviderItem.style.display = fixEnabled ? 'flex' : 'none';
  els.providerOpenAIBtn.classList.toggle('active', autoFixProvider === 'openai');
  els.providerLocalBtn.classList.toggle('active', autoFixProvider === 'local');
  
  // Show OpenAI key field when using OpenAI
  els.openAIKeyItem.style.display = (fixEnabled && autoFixProvider === 'openai') ? 'flex' : 'none';
  els.openAIKeyInput.value = openAIKey;
  
  // Show local model fields when using local LLM
  els.localModelItem.style.display = (fixEnabled && autoFixProvider === 'local') ? 'flex' : 'none';
  els.localModelStatusItem.style.display = (fixEnabled && autoFixProvider === 'local') ? 'flex' : 'none';
  els.localModelPath.value = localModelPath || '';
  
  // GitHub settings
  els.githubTokenInput.value = githubToken || '';
  els.githubRepoInput.value = githubRepo || '';
  els.publishingNameInput.value = publishingName || '';
  
  // Show/hide manual fix button
  els.fixBtn.style.display = (autoFixMode === 'manual') ? '' : 'none';
}

function applyTheme(theme) {
  currentTheme = theme;
  document.body.classList.toggle('dark-mode', theme === 'dark');
  api.savePreferences({ theme });
  updatePrefsUI();
}

function applyFocusStrength(strength) 
{
  currentFocusStrength = strength;
  document.documentElement.style.setProperty('--focus-strength', (strength / 100).toFixed(2));
  els.focusStrengthValue.textContent = `${strength}%`;
  api.savePreferences({ focusStrength: strength });
}

function setAutoFixMode(mode) 
{
  autoFixMode = mode;
  api.savePreferences({ autoFixMode: mode });
  // Show/hide manual fix button
  els.fixBtn.style.display = (mode === 'manual') ? '' : 'none';
  updatePrefsUI();
}

function setAutoFixProvider(provider) {
  autoFixProvider = provider;
  api.savePreferences({ autoFixProvider: provider });
  updatePrefsUI();
}

function saveOpenAIKey(key) {
  openAIKey = key;
  api.savePreferences({ openAIKey: key });
}

function saveGithubToken(token) {
  githubToken = token;
  api.savePreferences({ githubToken: token });
}

function saveGithubRepo(repo) {
  githubRepo = repo;
  api.savePreferences({ githubRepo: repo });
}

function savePublishingName(name) {
  publishingName = name;
  api.savePreferences({ publishingName: name });
}

async function browseForModel() {
  const result = await api.openModelDialog();
  if (result) {
    localModelPath = result;
    api.savePreferences({ localModelPath: result });
    updatePrefsUI();
    updateLocalModelStatus();
  }
}

// Fix text using OpenAI API or Local LLM
// isManual = true bypasses the mode check (for manual button press)
async function fixText(isManual = false) {
  // For auto mode, only run if auto mode is enabled
  if (!isManual && autoFixMode !== 'auto') return;
  if (isAutoFixing) return;
  if (autoFixProvider === 'openai' && !openAIKey) return;
  if (autoFixProvider === 'local' && !localModelPath) return;
  if (currentIndex == null || !notes[currentIndex]) return;
  
  const editor = els.editor;
  const text = editor.value;
  if (!text || text.trim().length < 10) return; // Don't fix very short text
  
  isAutoFixing = true;
  const originalSaveState = els.saveState.textContent;
  els.saveState.textContent = 'fixing...';
  
  // Add visual feedback for manual fix button
  if (isManual) {
    els.fixBtn.classList.add('fixing');
  }
  
  try {
    let fixedText;
    
    console.log('Fix starting, provider:', autoFixProvider, 'manual:', isManual);
    
    if (autoFixProvider === 'openai') {
      fixedText = await fixTextWithOpenAI(text);
    } else {
      fixedText = await fixTextWithLocalLLM(text);
    }
    
    console.log('Fix result:', fixedText ? 'got response' : 'no response');
    if (fixedText) {
      console.log('Original text:', JSON.stringify(text));
      console.log('Fixed text:', JSON.stringify(fixedText));
      console.log('Are they different?', fixedText.trim() !== text.trim());
    }
    
    if (fixedText && fixedText.trim() !== text.trim()) {
      // Preserve cursor position as best we can
      const cursorPos = editor.selectionStart;
      const cursorRatio = cursorPos / text.length;
      
      editor.value = fixedText;
      notes[currentIndex].content = fixedText;
      dirty = true;
      scheduleSave();
      
      // Restore cursor position proportionally
      const newCursorPos = Math.min(Math.round(cursorRatio * fixedText.length), fixedText.length);
      editor.selectionStart = editor.selectionEnd = newCursorPos;
      
      els.saveState.textContent = 'fixed ‚úì';
      console.log('Text was fixed');
    } else if (fixedText) {
      // Response came back but no changes
      els.saveState.textContent = 'no fixes needed';
      console.log('No fixes needed - text unchanged');
      setTimeout(() => {
        if (els.saveState.textContent === 'no fixes needed') {
          els.saveState.textContent = originalSaveState;
        }
      }, 2000);
    } else {
      // No response or error
      els.saveState.textContent = 'fix failed';
      console.log('Fix failed - no response');
      setTimeout(() => {
        if (els.saveState.textContent === 'fix failed') {
          els.saveState.textContent = originalSaveState;
        }
      }, 2000);
    }
  } catch (err) {
    console.error('Fix error:', err);
    els.saveState.textContent = 'fix error';
    setTimeout(() => {
      if (els.saveState.textContent === 'fix error') {
        els.saveState.textContent = originalSaveState;
      }
    }, 2000);
  } finally {
    isAutoFixing = false;
    els.fixBtn.classList.remove('fixing');
  }
}

async function fixTextWithOpenAI(text) {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${openAIKey}`
    },
    body: JSON.stringify({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: 'You are a text correction assistant. Fix spelling, grammar, and typos in the user\'s text. Keep the exact same meaning, tone, and structure. Only fix obvious errors. Return ONLY the corrected text with no explanations or quotes. If the text has no errors, return it unchanged.'
        },
        {
          role: 'user',
          content: text
        }
      ],
      temperature: 0.1,
      max_tokens: 4096
    })
  });
  
  if (!response.ok) {
    console.error('OpenAI API error:', response.status);
    return null;
  }
  
  const data = await response.json();
  return data.choices?.[0]?.message?.content || null;
}

async function fixTextWithLocalLLM(text) {
  try {
    console.log('Calling local LLM with text length:', text.length);
    const result = await api.runLocalLLM(localModelPath, text);
    console.log('Local LLM result:', result.success, 'response length:', result.text?.length);
    if (result.success) {
      // Log if there were changes
      if (result.text !== text) {
        console.log('Text was modified by local LLM');
      } else {
        console.log('Text unchanged by local LLM');
      }
      return result.text;
    } else {
      console.error('Local LLM error:', result.error);
      return null;
    }
  } catch (err) {
    console.error('Local LLM error:', err);
    return null;
  }
}

async function updateLocalModelStatus() {
  if (!localModelPath) {
    els.localModelStatus.textContent = 'No model selected';
    return;
  }
  
  try {
    const exists = await api.fileExists(localModelPath);
    if (exists) {
      els.localModelStatus.textContent = 'Model file found ‚úì';
      els.localModelStatus.style.color = '#2a5';
    } else {
      els.localModelStatus.textContent = 'Model file not found';
      els.localModelStatus.style.color = 'var(--danger)';
    }
  } catch (_e) {
    els.localModelStatus.textContent = 'Error checking model';
    els.localModelStatus.style.color = 'var(--danger)';
  }
}

function scheduleAutoFix() {
  // Only schedule auto-fix in auto mode
  if (autoFixMode !== 'auto') return;
  // Check if we have the required config for the selected provider
  if (autoFixProvider === 'openai' && !openAIKey) return;
  if (autoFixProvider === 'local' && !localModelPath) return;
  
  if (autoFixTimer) clearTimeout(autoFixTimer);
  autoFixTimer = setTimeout(() => fixText(false), AUTO_FIX_DEBOUNCE_MS);
}

// Manual fix triggered by button
function manualFix() {
  if (autoFixMode !== 'manual') return;
  fixText(true);
}

async function loadPreferences() {
  try {
    const prefs = await api.getPreferences();
    currentTheme = prefs.theme || 'light';
    currentFocusStrength = prefs.focusStrength !== undefined ? prefs.focusStrength : 70;
    // Handle legacy autoFixEnabled boolean -> convert to mode
    if (prefs.autoFixMode) {
      autoFixMode = prefs.autoFixMode;
    } else if (prefs.autoFixEnabled) {
      autoFixMode = 'auto'; // Legacy: true -> auto mode
    } else {
      autoFixMode = 'off';
    }
    autoFixProvider = prefs.autoFixProvider || 'openai';
    openAIKey = prefs.openAIKey || '';
    localModelPath = prefs.localModelPath || '';
    githubToken = prefs.githubToken || '';
    githubRepo = prefs.githubRepo || '';
    publishingName = prefs.publishingName || '';
    document.body.classList.toggle('dark-mode', currentTheme === 'dark');
    document.documentElement.style.setProperty('--focus-strength', (currentFocusStrength / 100).toFixed(2));
    
    // Show/hide manual fix button based on mode
    els.fixBtn.style.display = (autoFixMode === 'manual') ? '' : 'none';
    
    // Check model status if local LLM is configured
    if (localModelPath) {
      updateLocalModelStatus();
    }
  } catch (_e) {
    // ignore
  }
}

function renderList() {
  const q = (els.searchInput.value || '').trim().toLowerCase();
  els.list.innerHTML = '';

  if (!folderPath) {
    els.list.innerHTML = '<div class="empty">No folder open.</div>';
    return;
  }

  // Filter and sort notes
  const filteredNotes = notes
    .map((n, idx) => ({n, idx, isFolder: false}))
    .filter(({n}) => {
      if (!q) return true;
      return (n.title || '').toLowerCase().includes(q) || (n.content || '').toLowerCase().includes(q);
    })
    .sort((a,b) => (b.n.lastModified - a.n.lastModified) || a.n.title.localeCompare(b.n.title, undefined, {sensitivity:'base'}));

  // Filter folders (only show if no search query or folder name matches)
  const filteredFolders = subfolders
    .filter(f => {
      if (!q) return true;
      return f.name.toLowerCase().includes(q);
    })
    .sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));

  currentListOrder = filteredNotes.map(x => x.idx);

  if (filteredNotes.length === 0 && filteredFolders.length === 0) {
    els.list.innerHTML = '<div class="empty">No matches.</div>';
    return;
  }

  const frag = document.createDocumentFragment();
  
  // Render folders first
  for (const folder of filteredFolders) {
    const item = document.createElement('div');
    item.className = 'noteItem folder';

    const title = document.createElement('div');
    title.className = 'noteTitle';
    title.textContent = folder.name;

    const meta = document.createElement('div');
    meta.className = 'noteMeta';
    meta.textContent = `${fmtDate(folder.lastModified)}  ¬∑  folder`;

    item.appendChild(title);
    item.appendChild(meta);
    
    // Double-click to open folder
    item.addEventListener('dblclick', () => {
      openSubfolder(folder.path, folder.name);
    });
    // Single click just selects visually (optional feedback)
    item.addEventListener('click', () => {
      setListNav(true);
      setFocusMode(false);
    });
    
    frag.appendChild(item);
  }
  
  // Render notes
  for (const {n, idx} of filteredNotes) {
    const item = document.createElement('div');
    item.className = 'noteItem' + (idx === currentIndex ? ' active' : '');

    const title = document.createElement('div');
    title.className = 'noteTitle';
    title.textContent = n.title;

    const meta = document.createElement('div');
    meta.className = 'noteMeta';
    const firstLine = (n.content || '').split(/\r?\n/)[0]?.trim() || '';
    const excerpt = firstLine ? firstLine.slice(0, 80) : '(empty)';
    const canvasMark = n.canvas ? '  ¬∑  [canvas]' : (n.image ? '  ¬∑  [img]' : '');
    const audioMark = n.audio ? '  ¬∑  [audio]' : '';
    meta.textContent = `${fmtDate(n.lastModified)}  ¬∑  ${excerpt}${canvasMark}${audioMark}`;

    item.appendChild(title);
    item.appendChild(meta);
    item.addEventListener('click', () => { setListNav(true); openNoteByIndex(idx, { focusEditor:false, focusMode:false, keepListNav:true }); });
    frag.appendChild(item);
  }
  els.list.appendChild(frag);
}

function renderCurrent() {
  if (currentIndex == null || !notes[currentIndex]) {
    els.currentTitle.textContent = 'No note selected';
    els.saveState.textContent = '';
    els.editorWrap.style.display = 'none';
    els.empty.style.display = 'block';
    setEditorEnabled(false);
    clearThumb();
    hideCanvasWorkspace();
    return;
  }

  const n = notes[currentIndex];
  els.currentTitle.textContent = n.name;
  els.editor.value = n.content ?? '';
  els.editorWrap.style.display = 'flex';
  els.empty.style.display = 'none';
  setEditorEnabled(true);
  els.saveState.textContent = '';
  els.editorWrap.classList.remove('hasImage');
  dirty = false;
}

async function openFolder() {
  hideBanner();
  try {
    const selectedPath = await api.openFolderDialog();
    if (!selectedPath) return;
    
    rootFolderPath = selectedPath;
    folderPath = selectedPath;
    await api.saveFolderPath(folderPath);
    setEnabled(true);
    updateFolderUI();
    await reloadNotes();
  } catch (err) {
    showBanner(`Could not open folder. ${String(err?.message || err)}`);
  }
}

async function loadFolderFromPath(path) {
  rootFolderPath = path;
  folderPath = path;
  setEnabled(true);
  updateFolderUI();
  await reloadNotes();
}

// Navigate into a subfolder
async function openSubfolder(subPath, folderName) {
  hideBanner();
  try {
    await flushSaveIfNeeded();
    folderPath = subPath;
    updateFolderUI();
    await reloadNotes();
  } catch (err) {
    showBanner(`Could not open folder. ${String(err?.message || err)}`);
  }
}

// Navigate up one level in the folder hierarchy
async function navigateUp() {
  if (!rootFolderPath || !folderPath || folderPath === rootFolderPath) return;
  
  hideBanner();
  try {
    await flushSaveIfNeeded();
    // Go up one level using dirname
    folderPath = api.dirname(folderPath);
    updateFolderUI();
    await reloadNotes();
  } catch (err) {
    showBanner(`Could not navigate back. ${String(err?.message || err)}`);
  }
}

// Update UI elements for folder navigation (back button, breadcrumb)
function updateFolderUI() {
  const isInSubfolder = rootFolderPath && folderPath && folderPath !== rootFolderPath;
  
  // Show/hide back button
  els.backBtn.style.display = isInSubfolder ? '' : 'none';
  
  // Show/hide breadcrumb
  if (isInSubfolder) {
    // Build full breadcrumb showing path from root to current folder
    const rootName = api.basename(rootFolderPath);
    let relativePath = folderPath.slice(rootFolderPath.length);
    // Remove leading separator if present
    if (relativePath.startsWith('/') || relativePath.startsWith('\\')) {
      relativePath = relativePath.slice(1);
    }
    // Split path into segments
    const segments = relativePath.split(/[/\\]/).filter(s => s.length > 0);
    els.folderBreadcrumb.textContent = `${rootName} / ${segments.join(' / ')}`;
    els.folderBreadcrumb.style.display = 'block';
  } else {
    els.folderBreadcrumb.style.display = 'none';
  }
}

// Create a new subfolder in the current folder
async function newFolder() {
  if (!folderPath) return;
  
  const raw = await api.showPrompt('New folder name:', '');
  if (raw == null) return;

  // Sanitize folder name (similar to note title sanitization)
  let folderName = (raw || '').trim();
  folderName = folderName.replace(/[\\\/:*?"<>|]/g, ' ');
  folderName = folderName.replace(/\s+/g, ' ').trim();
  if (folderName.length > 120) folderName = folderName.slice(0, 120).trim();
  
  if (!folderName) {
    await api.showAlert('Folder name cannot be empty.');
    return;
  }

  // Check if folder already exists
  if (subfolders.some(f => f.name.toLowerCase() === folderName.toLowerCase())) {
    await api.showAlert('A folder with that name already exists.');
    return;
  }

  try {
    const newFolderPath = api.joinPath(folderPath, folderName);
    const result = await api.createFolder(newFolderPath);
    if (!result.success) {
      showBanner(`Could not create folder. ${result.error}`);
      return;
    }

    // Reload to show the new folder
    await reloadNotes();
  } catch (err) {
    showBanner(`Could not create folder. ${String(err?.message || err)}`);
  }
}

async function reloadNotes(preserveName = null) {
  if (!folderPath) return;

  const q = els.searchInput.value || '';
  if (!preserveName && currentIndex != null && notes[currentIndex]) preserveName = notes[currentIndex].name;

  notes = [];
  subfolders = [];
  currentIndex = null;
  renderCurrent();

  try {
    const result = await api.readFolder(folderPath);
    if (!result.success) {
      showBanner(`Could not read folder. ${result.error}`);
      return;
    }

    // Store subfolders - show at all levels for nested navigation
    if (result.folders) {
      subfolders = result.folders;
    }

    const attachments = new Map();
    const audioAttachments = new Map();
    const canvasAttachments = new Map();

    for (const file of result.files) {
      if (file.type === 'text') {
        notes.push({
          name: file.name,
          title: noteTitleFromName(file.name),
          path: api.joinPath(folderPath, file.name),
          content: file.content,
          size: file.size,
          lastModified: file.lastModified,
          image: null,
          audio: null,
          canvas: null
        });
      } else if (file.type === 'image') {
        const baseKey = attachmentBaseKeyFromName(file.name);
        if (!baseKey) continue;
        const prev = attachments.get(baseKey);
        if (!prev || file.lastModified > prev.lastModified) {
          attachments.set(baseKey, {
            name: file.name,
            path: api.joinPath(folderPath, file.name),
            lastModified: file.lastModified,
            size: file.size
          });
        }
      } else if (file.type === 'audio') {
        const baseKey = audioBaseKeyFromName(file.name);
        if (!baseKey) continue;
        const prev = audioAttachments.get(baseKey);
        if (!prev || file.lastModified > prev.lastModified) {
          audioAttachments.set(baseKey, {
            name: file.name,
            path: api.joinPath(folderPath, file.name),
            lastModified: file.lastModified,
            size: file.size
          });
        }
      } else if (file.type === 'canvas') {
        // Canvas JSON files are named like "NoteName.canvas.json"
        const baseKey = file.name.toLowerCase().replace('.canvas.json', '');
        canvasAttachments.set(baseKey, {
          name: file.name,
          jsonPath: api.joinPath(folderPath, file.name),
          pngPath: api.joinPath(folderPath, file.name.replace('.canvas.json', '.canvas.png')),
          lastModified: file.lastModified
        });
      }
    }

    for (const n of notes) {
      const baseKey = noteTitleFromName(n.name).toLowerCase();
      const att = attachments.get(baseKey);
      if (att) n.image = att;
      const audioAtt = audioAttachments.get(baseKey);
      if (audioAtt) n.audio = audioAtt;
      const canvasAtt = canvasAttachments.get(baseKey);
      if (canvasAtt) n.canvas = canvasAtt;
    }

    if (preserveName) {
      const idx = notes.findIndex(n => n.name.toLowerCase() === String(preserveName).toLowerCase());
      if (idx >= 0) currentIndex = idx;
    }

    els.searchInput.value = q;
    renderList();
    renderCurrent();

    if (currentIndex != null && notes[currentIndex]) {
      await renderImage();
    }
  } catch (err) {
    showBanner(`Could not read folder. ${String(err?.message || err)}`);
  }
}

async function flushSaveIfNeeded() {
  if (saveTimer) {
    clearTimeout(saveTimer);
    saveTimer = null;
  }
  if (maxSaveTimer) {
    clearTimeout(maxSaveTimer);
    maxSaveTimer = null;
  }
  if (autoFixTimer) {
    clearTimeout(autoFixTimer);
    autoFixTimer = null;
  }
  if (dirty && !isSaving) {
    await saveCurrentNow();
  }
}

async function refreshNotes() {
  if (!folderPath) return;
  const preserveName = (currentIndex != null && notes[currentIndex]) ? notes[currentIndex].name : null;
  const keepFocus = document.body.classList.contains('focusMode');
  await flushSaveIfNeeded();
  await reloadNotes(preserveName);
  if (keepFocus) setFocusMode(true);
}

// Check if a note is empty (no text, no image, no canvas content, no audio)
// Pass editorContent when checking the currently active note to ensure we get the latest value
// This is async because it may need to check canvas file contents
async function isNoteEmpty(n, editorContent = null) {
  if (!n) return false;
  
  // Use provided editorContent if given, otherwise fall back to n.content
  const textContent = editorContent !== null ? editorContent : (n.content || '');
  const hasText = textContent.trim().length > 0;
  const hasImage = !!(n.image && n.image.path);
  const hasAudio = !!(n.audio && n.audio.path);
  
  // For canvas, we need to check if the file actually has objects, not just if the path exists
  let hasCanvasContent = false;
  if (n.canvas && n.canvas.jsonPath) {
    try {
      const result = await api.readCanvasJson(n.canvas.jsonPath);
      if (result.success && result.data) {
        const canvasData = JSON.parse(result.data);
        // Check if canvas has any objects
        hasCanvasContent = canvasData.objects && canvasData.objects.length > 0;
      }
    } catch (e) {
      // If we can't read/parse the file, assume no canvas content
      hasCanvasContent = false;
    }
  }
  
  console.log('[isNoteEmpty] Check:', { 
    hasText, 
    textLength: textContent.trim().length,
    hasImage, 
    hasCanvasContent,
    canvasPath: n.canvas?.jsonPath || null,
    hasAudio,
    result: !hasText && !hasImage && !hasCanvasContent && !hasAudio 
  });
  
  return !hasText && !hasImage && !hasCanvasContent && !hasAudio;
}

// Auto-delete an empty note without confirmation
// editorContent should be passed when deleting the currently active note
async function autoDeleteEmptyNote(noteIndex, editorContent = null) {
  console.log('[AutoDelete] autoDeleteEmptyNote called with index:', noteIndex);
  if (noteIndex == null || !notes[noteIndex] || !folderPath) {
    console.log('[AutoDelete] Bailing early - null index, no note, or no folder');
    return;
  }
  const n = notes[noteIndex];
  
  // Double-check the note is actually empty (use editorContent if provided)
  if (!(await isNoteEmpty(n, editorContent))) {
    console.log('[AutoDelete] Note not empty on double-check, aborting');
    return;
  }
  
  try {
    console.log('[AutoDelete] Deleting file:', n.path);
    // Delete the note file silently
    await api.deleteFile(n.path);
    
    // Delete any orphaned canvas files just in case
    const base = noteTitleFromName(n.name);
    const basePath = api.joinPath(folderPath, base);
    await api.deleteCanvasFiles(basePath);
    
    // Remove from notes array
    notes.splice(noteIndex, 1);
    
    console.log('[AutoDelete] Successfully auto-deleted empty note:', n.name);
  } catch (err) {
    // Silently ignore errors - the note might already be deleted
    console.warn('[AutoDelete] Failed to auto-delete empty note:', err);
  }
}

async function openNoteByIndex(idx, opts = {}) {
  const { focusEditor = true, focusMode = true, keepListNav = false } = (opts || {});
  if (idx == null || !notes[idx]) return;
  closeLightbox();
  stopAudio();
  
  // Save current canvas before switching
  if (canvasDirty && fabricCanvas && currentIndex != null) {
    await saveCanvasState();
  }
  
  // Auto-delete the previous note if it was empty (Apple Notes-like behavior)
  // Check BEFORE flushing to ensure we capture the current editor state
  const previousIndex = currentIndex;
  const editorContent = els.editor ? els.editor.value : '';
  
  console.log('[AutoDelete] Switching from index', previousIndex, 'to index', idx);
  
  await flushSaveIfNeeded();
  
  if (previousIndex != null && previousIndex !== idx && notes[previousIndex]) {
    const prevNote = notes[previousIndex];
    console.log('[AutoDelete] Checking note:', prevNote.name);
    console.log('[AutoDelete] - editor content length:', editorContent.trim().length);
    console.log('[AutoDelete] - has image:', !!(prevNote.image && prevNote.image.path));
    console.log('[AutoDelete] - has canvas:', !!(prevNote.canvas && (prevNote.canvas.jsonPath || prevNote.canvas.pngPath)));
    console.log('[AutoDelete] - has audio:', !!(prevNote.audio && prevNote.audio.path));
    
    // Pass editor content directly to ensure we check the current state
    if (await isNoteEmpty(notes[previousIndex], editorContent)) {
      console.log('[AutoDelete] Note is empty, deleting:', prevNote.name);
      await autoDeleteEmptyNote(previousIndex, editorContent);
      // Adjust the target index if it was after the deleted note
      if (idx > previousIndex) {
        idx = idx - 1;
        console.log('[AutoDelete] Adjusted target index to:', idx);
      }
      // If the target note no longer exists, bail
      if (!notes[idx]) {
        console.log('[AutoDelete] Target note no longer exists, bailing');
        currentIndex = null;
        renderCurrent();
        renderList();
        return;
      }
    }
  }
  
  currentIndex = idx;
  renderCurrent();
  renderList();
  await renderImage();
  // Auto-play audio if the note has one
  if (notes[idx] && notes[idx].audio) {
    await playCurrentAudio();
  }
  if (focusEditor) els.editor.focus();
  if (focusMode) setFocusMode(true);
  if (keepListNav) setListNav(true);
}

async function saveCurrentNow() {
  if (currentIndex == null || !notes[currentIndex]) return;
  if (!dirty) return;

  const n = notes[currentIndex];
  isSaving = true;
  els.saveState.textContent = 'saving‚Ä¶';

  try {
    const result = await api.writeFile(n.path, n.content ?? '');
    if (!result.success) {
      els.saveState.textContent = 'save failed';
      showBanner(`Save failed. ${result.error}`);
      return;
    }
    n.size = result.size;
    n.lastModified = result.lastModified;
    dirty = false;
    // Clear max interval timer since we just saved
    if (maxSaveTimer) {
      clearTimeout(maxSaveTimer);
      maxSaveTimer = null;
    }
    els.saveState.textContent = `saved ${fmtDate(n.lastModified)}`;
    renderList();
  } catch (err) {
    els.saveState.textContent = 'save failed';
    showBanner(`Save failed. ${String(err?.message || err)}`);
  } finally {
    isSaving = false;
  }
}

function scheduleSave() {
  // Clear existing debounce timer and restart it
  if (saveTimer) clearTimeout(saveTimer);
  
  // Schedule save after user stops typing (debounced)
  const doSave = () => {
    // Use requestIdleCallback if available for smoother saves
    if (window.requestIdleCallback) {
      requestIdleCallback(() => saveCurrentNow(), { timeout: 2000 });
    } else {
      saveCurrentNow();
    }
  };
  
  saveTimer = setTimeout(doSave, SAVE_DEBOUNCE_MS);
  
  // Start max interval timer if not already running
  // This ensures we save even during continuous typing
  if (!maxSaveTimer && dirty) {
    maxSaveTimer = setTimeout(() => {
      maxSaveTimer = null;
      if (dirty && !isSaving) {
        // Clear debounce timer since we're forcing a save
        if (saveTimer) {
          clearTimeout(saveTimer);
          saveTimer = null;
        }
        doSave();
      }
    }, SAVE_MAX_INTERVAL_MS);
  }
}

async function newNote() {
  if (!folderPath) return;
  
  stopAudio();
  
  const raw = await api.showPrompt('New note title (this becomes the filename):', '');
  if (raw == null) return;

  const title = sanitizeTitleToFilename(raw);
  if (!title) {
    await api.showAlert('Title cannot be empty.');
    return;
  }

  let name = `${title}.txt`;
  let i = 1;
  while (notes.some(n => n.name.toLowerCase() === name.toLowerCase())) {
    name = `${title} (${i++}).txt`;
  }

  try {
    await flushSaveIfNeeded();
    const notePath = api.joinPath(folderPath, name);
    const result = await api.writeFile(notePath, '');
    if (!result.success) {
      showBanner(`Could not create note. ${result.error}`);
      return;
    }

    notes.push({
      name,
      title: noteTitleFromName(name),
      path: notePath,
      content: '',
      size: result.size,
      lastModified: result.lastModified,
      image: null,
      audio: null,
      canvas: null
    });

    const idx = notes.findIndex(n => n.name === name);
    await openNoteByIndex(idx);
  } catch (err) {
    showBanner(`Could not create note. ${String(err?.message || err)}`);
  }
}

async function deleteCurrent() {
  if (currentIndex == null || !notes[currentIndex] || !folderPath) return;
  const n = notes[currentIndex];
  
  const yes = await api.showConfirm(`Delete "${n.name}"? This removes the .txt file and all attachments from the folder.`);
  if (!yes) return;

  stopAudio();

  try {
    await flushSaveIfNeeded();

    if (n.image?.path) {
      await api.deleteFile(n.image.path);
    }
    if (n.audio?.path) {
      await api.deleteFile(n.audio.path);
    }
    // Delete canvas files
    const base = noteTitleFromName(n.name);
    const basePath = api.joinPath(folderPath, base);
    await api.deleteCanvasFiles(basePath);
    
    await api.deleteFile(n.path);

    notes.splice(currentIndex, 1);
    currentIndex = null;
    hideCanvasWorkspace();
    renderCurrent();
    renderList();
  } catch (err) {
    showBanner(`Delete failed. ${String(err?.message || err)}`);
  }
}

async function attachImage() {
  if (!folderPath) return;
  if (currentIndex == null || !notes[currentIndex]) return;
  const n = notes[currentIndex];

  try {
    const fileData = await api.openImageDialog();
    if (!fileData) return;

    const ext = fileData.ext || 'png';
    const base = noteTitleFromName(n.name);
    const destName = `${base}.${ext}`;
    const destPath = api.joinPath(folderPath, destName);

    // Remove prior attachments for this note
    for (const oldExt of ['png','jpg','jpeg','gif','webp']) {
      const oldPath = api.joinPath(folderPath, `${base}.${oldExt}`);
      if (oldPath !== destPath) {
        await api.deleteFile(oldPath);
      }
    }

    // Write the new image
    const base64Data = `data:image/${ext};base64,${fileData.buffer}`;
    const result = await api.writeImageBuffer(destPath, base64Data);
    if (!result.success) {
      showBanner(`Could not attach image. ${result.error}`);
      return;
    }

    n.image = { name: destName, path: destPath, lastModified: result.lastModified, size: result.size };
    await renderImage();
    renderList();
  } catch (err) {
    if (err && err.name !== 'AbortError') {
      showBanner(`Could not attach image. ${String(err?.message || err)}`);
    }
  }
}

// Events
els.openBtn.addEventListener('click', () => { setFocusMode(false); openFolder(); });
els.backBtn.addEventListener('click', () => { setFocusMode(false); navigateUp(); });
els.newFolderBtn.addEventListener('click', () => { setFocusMode(false); newFolder(); });
els.newBtn.addEventListener('click', newNote);
els.refreshBtn.addEventListener('click', refreshNotes);
els.deleteBtn.addEventListener('click', deleteCurrent);
els.attachBtn.addEventListener('click', addImageFromDialog);
els.drawBtn.addEventListener('click', openDrawModal);
els.drawSaveBtn.addEventListener('click', saveDrawingAsAttachment);
els.drawCloseBtn.addEventListener('click', closeDrawModal);
els.drawNewBtn.addEventListener('click', () => clearCanvasWhite());
els.drawDeleteBtn.addEventListener('click', deleteDrawingAttachment);

els.audioBtn.addEventListener('click', openAudioModal);
els.audioCloseBtn.addEventListener('click', closeAudioModal);
els.audioLoadBtn.addEventListener('click', loadAudioFile);
els.audioPlayBtn.addEventListener('click', playCurrentAudio);
els.audioStopBtn.addEventListener('click', stopAudio);
els.audioDeleteBtn.addEventListener('click', deleteAudioFile);
els.audioModal.addEventListener('mousedown', (e) => { if (e.target === els.audioModal) closeAudioModal(); });

// Canvas workspace event listeners
els.canvasSelectBtn.addEventListener('click', () => setCanvasDrawingMode(false));
els.canvasDrawBtn.addEventListener('click', () => setCanvasDrawingMode(true));
els.canvasAddImageBtn.addEventListener('click', addImageFromDialog);
els.canvasDeleteObjBtn.addEventListener('click', deleteSelectedObjects);
els.canvasClearBtn.addEventListener('click', async () => {
  const yes = await api.showConfirm('Clear entire canvas? This cannot be undone.');
  if (yes) {
    clearCanvas();
    await saveCanvasState();
  }
});
els.dropBrowseBtn.addEventListener('click', addImageFromDialog);

els.prefsCloseBtn.addEventListener('click', closePrefsModal);
els.prefsModal.addEventListener('mousedown', (e) => { if (e.target === els.prefsModal) closePrefsModal(); });

// Export modal event listeners
els.exportBtn.addEventListener('click', () => { setFocusMode(false); openExportModal(); });
els.exportCloseBtn.addEventListener('click', closeExportModal);
els.exportModal.addEventListener('mousedown', (e) => { if (e.target === els.exportModal) closeExportModal(); });
els.exportPdfBtn.addEventListener('click', exportToPdf);
els.exportPngBtn.addEventListener('click', exportToPng);
els.exportEpubBtn.addEventListener('click', exportToEpub);
els.exportHtmlBtn.addEventListener('click', exportToHtml);
els.publishGithubBtn.addEventListener('click', publishToGithub);

els.themeLightBtn.addEventListener('click', () => applyTheme('light'));
els.themeDarkBtn.addEventListener('click', () => applyTheme('dark'));
els.focusStrengthSlider.addEventListener('input', (e) => applyFocusStrength(parseInt(e.target.value, 10)));
els.autoFixOffBtn.addEventListener('click', () => setAutoFixMode('off'));
els.autoFixAutoBtn.addEventListener('click', () => setAutoFixMode('auto'));
els.autoFixManualBtn.addEventListener('click', () => setAutoFixMode('manual'));
els.providerOpenAIBtn.addEventListener('click', () => setAutoFixProvider('openai'));
els.providerLocalBtn.addEventListener('click', () => setAutoFixProvider('local'));
els.openAIKeyInput.addEventListener('change', (e) => saveOpenAIKey(e.target.value));
els.openAIKeyInput.addEventListener('blur', (e) => saveOpenAIKey(e.target.value));

// GitHub settings handlers
els.githubTokenInput.addEventListener('change', (e) => saveGithubToken(e.target.value));
els.githubTokenInput.addEventListener('blur', (e) => saveGithubToken(e.target.value));
els.githubRepoInput.addEventListener('change', (e) => saveGithubRepo(e.target.value));
els.githubRepoInput.addEventListener('blur', (e) => saveGithubRepo(e.target.value));
els.publishingNameInput.addEventListener('change', (e) => savePublishingName(e.target.value));
els.publishingNameInput.addEventListener('blur', (e) => savePublishingName(e.target.value));
els.browseModelBtn.addEventListener('click', () => browseForModel());
els.fixBtn.addEventListener('click', () => manualFix());

// Listen for menu open-preferences event
api.onOpenPreferences(() => openPrefsModal());

els.drawCanvas.addEventListener('pointerdown', (e) => { e.preventDefault(); els.drawCanvas.setPointerCapture(e.pointerId); beginStroke(e); });
els.drawCanvas.addEventListener('pointermove', (e) => { if (!drawIsDown) return; e.preventDefault(); moveStroke(e); });
els.drawCanvas.addEventListener('pointerup', (e) => { e.preventDefault(); endStroke(); });
els.drawCanvas.addEventListener('pointercancel', () => endStroke());

els.drawModal.addEventListener('mousedown', (e) => { if (e.target === els.drawModal) closeDrawModal(); });
els.searchInput.addEventListener('focus', async () => {
  setListNav(false);
  setFocusMode(false);
  
  // Auto-delete the current note if it's empty when clicking away to search
  console.log('[AutoDelete:Search] Search focused, currentIndex:', currentIndex);
  if (currentIndex != null && notes[currentIndex]) {
    // Get editor content BEFORE any async operations
    const editorContent = els.editor ? els.editor.value : '';
    
    const n = notes[currentIndex];
    console.log('[AutoDelete:Search] Checking note:', n.name);
    console.log('[AutoDelete:Search] - editor content length:', editorContent.trim().length);
    
    // Pass editor content directly to ensure we check the current state
    if (await isNoteEmpty(notes[currentIndex], editorContent)) {
      console.log('[AutoDelete:Search] Note is empty, deleting');
      await autoDeleteEmptyNote(currentIndex, editorContent);
      currentIndex = null;
      renderCurrent();
      renderList();
    }
  }
});
els.searchInput.addEventListener('input', () => { setFocusMode(false); renderList(); });
els.list.addEventListener('mousedown', () => { setListNav(true); setFocusMode(false); });
els.list.addEventListener('wheel', () => { setListNav(true); setFocusMode(false); });
els.editor.addEventListener('focus', () => { setListNav(false); setFocusMode(true); });

els.editor.addEventListener('input', () => {
  setListNav(false);
  if (currentIndex == null || !notes[currentIndex]) return;
  notes[currentIndex].content = els.editor.value;
  dirty = true;
  els.saveState.textContent = 'modified';
  scheduleSave();
  scheduleAutoFix();
  // Don't call renderList() here - it's expensive and causes UI stutter
  // The list will update after save completes
  setFocusMode(true);
});

// Drag and drop file paths into editor
els.editor.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
});

els.editor.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();
  
  if (currentIndex == null || !notes[currentIndex]) return;
  
  const files = e.dataTransfer.files;
  if (files.length === 0) return;
  
  // Build string of file paths (one per line if multiple)
  const paths = [];
  for (let i = 0; i < files.length; i++) {
    // Use Electron's webUtils to get the actual file path
    const filePath = api.getPathForFile(files[i]);
    if (filePath) {
      paths.push(filePath);
    }
  }
  
  if (paths.length === 0) return;
  
  const pathString = paths.join('\n');
  
  // Insert at cursor position
  const editor = els.editor;
  const start = editor.selectionStart;
  const end = editor.selectionEnd;
  const value = editor.value;
  
  editor.value = value.substring(0, start) + pathString + value.substring(end);
  editor.selectionStart = editor.selectionEnd = start + pathString.length;
  
  // Update note and trigger save
  notes[currentIndex].content = editor.value;
  dirty = true;
  els.saveState.textContent = 'modified';
  scheduleSave();
  editor.focus();
});

els.thumb.addEventListener('click', openLightbox);
els.lightbox.addEventListener('click', closeLightbox);
window.addEventListener('resize', () => {
  if (drawIsOpen) resizeDrawCanvas(true);
});

window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    if (exportIsOpen && !isExporting) { closeExportModal(); return; }
    if (prefsIsOpen) { closePrefsModal(); return; }
    if (audioIsOpen) { closeAudioModal(); return; }
    if (drawIsOpen) { closeDrawModal(); return; }
    closeLightbox();
    return;
  }

   // Tab key in editor - indent with spaces (and indent selection by lines)
  if (e.key === 'Tab' && document.activeElement === els.editor) {
    e.preventDefault();

    const editor = els.editor;
    const INDENT = '  '; // change to '    ' for 4 spaces

    const value = editor.value;
    const start = editor.selectionStart;
    const end = editor.selectionEnd;

    const lineStart = (pos) => value.lastIndexOf('\n', pos - 1) + 1;

    // Shift+Tab = outdent
    if (e.shiftKey) {
      const startLS = lineStart(start);
      const endLS = lineStart(end);

      // Outdent single line (no selection)
      if (start === end) {
        const prefix = value.slice(startLS, startLS + INDENT.length);
        if (prefix === INDENT) {
          editor.value = value.slice(0, startLS) + value.slice(startLS + INDENT.length);
          const newPos = Math.max(start - INDENT.length, startLS);
          editor.selectionStart = editor.selectionEnd = newPos;
          editor.dispatchEvent(new Event('input', { bubbles: true }));
        }
        return;
      }

      // Outdent all touched lines
      const blockStart = startLS;
      const blockEnd = end; // keep end as-is; we‚Äôll process line by line
      const block = value.slice(blockStart, blockEnd);
      const lines = block.split('\n');

      let removedFirstLine = 0;
      let removedTotal = 0;

      const outdented = lines.map((ln, i) => {
        if (ln.startsWith(INDENT)) {
          removedTotal += INDENT.length;
          if (i === 0) removedFirstLine = INDENT.length;
          return ln.slice(INDENT.length);
        }
        // also support literal tab characters if older notes contain them
        if (ln.startsWith('\t')) {
          removedTotal += 1;
          if (i === 0) removedFirstLine = 1;
          return ln.slice(1);
        }
        return ln;
      }).join('\n');

      editor.value = value.slice(0, blockStart) + outdented + value.slice(blockEnd);

      // Adjust selection
      editor.selectionStart = Math.max(start - removedFirstLine, blockStart);
      editor.selectionEnd = Math.max(end - removedTotal, editor.selectionStart);

      editor.dispatchEvent(new Event('input', { bubbles: true }));
      return;
    }

    // Tab (no Shift): indent
    // If selection spans multiple lines, indent all touched lines.
    if (start !== end) {
      const startLS = lineStart(start);
      const blockStart = startLS;
      const blockEnd = end;

      const block = value.slice(blockStart, blockEnd);
      const lines = block.split('\n');
      const indented = lines.map(ln => INDENT + ln).join('\n');

      editor.value = value.slice(0, blockStart) + indented + value.slice(blockEnd);

      const lineCount = lines.length;
      editor.selectionStart = start + INDENT.length;                 // selection shifts right by first-line indent
      editor.selectionEnd = end + (INDENT.length * lineCount);       // plus one indent per line

      editor.dispatchEvent(new Event('input', { bubbles: true }));
      return;
    }

    // No selection: just insert indent at caret (pushes the word to the right)
    editor.value = value.substring(0, start) + INDENT + value.substring(end);
    editor.selectionStart = editor.selectionEnd = start + INDENT.length;
    editor.dispatchEvent(new Event('input', { bubbles: true }));
    return;
  }

  // Canvas keyboard shortcuts (only when not in text editor or modals)
  const inTextInput = document.activeElement === els.editor || document.activeElement === els.searchInput;
  const canvasVisible = els.canvasWorkspace.style.display !== 'none' && currentIndex != null;
  const noModalsOpen = !prefsIsOpen && !audioIsOpen && !drawIsOpen;
  
  if (canvasVisible && noModalsOpen && !inTextInput) {
    // Delete key - delete selected objects
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (fabricCanvas && fabricCanvas.getActiveObjects().length > 0) {
        e.preventDefault();
        deleteSelectedObjects();
        return;
      }
    }
    
    // Spacebar - toggle between Select and Draw modes
    if (e.key === ' ') {
      e.preventDefault();
      setCanvasDrawingMode(!canvasDrawingMode);
      return;
    }
  }

  if (listNavActive && !drawIsOpen && !audioIsOpen && !prefsIsOpen) {
    if (e.key === 'ArrowDown' && !e.metaKey && !e.ctrlKey && !e.altKey) {
      e.preventDefault();
      moveSelectionInList(+1);
      return;
    }
    if (e.key === 'ArrowUp' && !e.metaKey && !e.ctrlKey && !e.altKey) {
      e.preventDefault();
      moveSelectionInList(-1);
      return;
    }
  }
});

window.addEventListener('beforeunload', (e) => {
  if (dirty || canvasDirty) {
    // Try to save canvas before closing
    if (canvasDirty && fabricCanvas) {
      saveCanvasState();
    }
    e.preventDefault();
    e.returnValue = '';
  }
});

// Save immediately when user switches away from window or app goes to background
window.addEventListener('blur', () => {
  if (dirty && !isSaving) {
    if (saveTimer) { clearTimeout(saveTimer); saveTimer = null; }
    if (maxSaveTimer) { clearTimeout(maxSaveTimer); maxSaveTimer = null; }
    saveCurrentNow();
  }
  if (canvasDirty && fabricCanvas) {
    saveCanvasState();
  }
});

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    if (dirty && !isSaving) {
      if (saveTimer) { clearTimeout(saveTimer); saveTimer = null; }
      if (maxSaveTimer) { clearTimeout(maxSaveTimer); maxSaveTimer = null; }
      saveCurrentNow();
    }
    if (canvasDirty && fabricCanvas) {
      saveCanvasState();
    }
  }
});

// Initialize
(async function init() {
  // Load preferences first (theme, focus strength)
  await loadPreferences();
  
  els.status.textContent = 'No folder open';
  setEnabled(false);
  setEditorEnabled(false);
  renderList();
  renderCurrent();
  try { resizeDrawCanvas(false); clearCanvasWhite(); } catch (_e) {}

  // Auto-load saved folder
  try {
    const savedFolder = await api.getSavedFolder();
    if (savedFolder) {
      // Check if folder still exists by trying to read it
      const result = await api.readFolder(savedFolder);
      if (result.success) {
        await loadFolderFromPath(savedFolder);
      }
    }
  } catch (_e) {
    // ignore
  }
})();

// --- ASCII boat animation ---
(function initBoatAnim() {
  const boatEl = document.getElementById('asciiBoat');
  if (!boatEl) return;
  if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

  const base = boatEl.textContent.replace(/\r/g, '');
  const lines = base.split('\n');
  const wavePattern = '^_^^^-^^_^^^^-^^^-^';

  const runsByLine = lines.map((line) => {
    const runs = [];
    const re = /\^+/g;
    let m;
    while ((m = re.exec(line)) !== null) {
      runs.push({ start: m.index, len: m[0].length });
    }
    return runs;
  });

  const stackRow = lines.findIndex(l => l.includes('[]'));
  const stackCol = stackRow >= 0 ? lines[stackRow].indexOf('[') : 0;
  const smokeRowCount = 3;
  const maxSmokeWidth = 18;
  const smokeWidth = Math.min(maxSmokeWidth, Math.max(8, stackCol));
  const smokeRows = [];
  const smokeStart = Math.max(0, Math.min(Math.max(0, stackCol - 1), stackCol - smokeWidth + 3));

  function extractRegion(line, start, len) {
    const s = String(line || '').padEnd(start + len, ' ');
    return s.slice(start, start + len);
  }
  function overlay(line, start, text) {
    const need = start + text.length;
    const chars = String(line || '').padEnd(need, ' ').split('');
    for (let i = 0; i < text.length; i++) chars[start + i] = text[i];
    return chars.join('');
  }
  function clearFromCol(line, col) {
    const chars = String(line || '').split('');
    for (let i = col; i < chars.length; i++) {
      if (chars[i] === 'o' || chars[i] === '.') chars[i] = ' ';
    }
    return chars.join('');
  }

  let seed = 123456789;
  function rand() {
    seed = (seed * 1664525 + 1013904223) >>> 0;
    return seed / 4294967296;
  }

  function driftAndFadeRow(row) {
    const shifted = row.slice(1) + ' ';
    const chars = shifted.split('');
    for (let i = 0; i < chars.length; i++) {
      const c = chars[i];
      if (c === 'o' && rand() < 0.30) chars[i] = '.';
      else if (c === '.' && rand() < 0.22) chars[i] = ' ';
    }
    return chars.join('');
  }

  function makeSeedRow() {
    const chars = Array(smokeWidth).fill(' ');
    const origin = Math.max(0, smokeWidth - 3);
    const count = 3 + Math.floor(rand() * 4);
    for (let i = 0; i < count; i++) {
      const driftLeft = Math.floor(rand() * 10);
      const pos = Math.max(0, origin - driftLeft);
      const far = (origin - pos) >= 5;
      chars[pos] = rand() < (far ? 0.20 : 0.55) ? 'o' : '.';
    }
    if (rand() < 0.55) {
      const pos = Math.max(0, origin - (8 + Math.floor(rand() * 8)));
      if (pos < smokeWidth && chars[pos] === ' ') chars[pos] = '.';
    }
    if (rand() < 0.30) {
      const pos = Math.max(0, origin - (10 + Math.floor(rand() * 6)));
      if (pos < smokeWidth && chars[pos] === ' ') chars[pos] = '.';
    }
    return chars.join('');
  }

  let smokeBuf = [];
  if (stackRow >= 0) {
    for (let r = Math.max(0, stackRow - smokeRowCount); r < stackRow; r++) {
      smokeRows.push(r);
    }
    smokeBuf = smokeRows.map(r => extractRegion(lines[r], smokeStart, smokeWidth));

    for (let j = 0; j < smokeRows.length; j++) {
      const row = smokeRows[j];
      const line = String(lines[row] || '');
      const chars = smokeBuf[j].split('');
      let insertPos = smokeWidth - 1;
      for (let c = stackCol; c < line.length; c++) {
        const ch = line[c];
        if (ch === 'o' || ch === '.') {
          while (insertPos >= 0 && chars[insertPos] === 'o') insertPos--;
          if (insertPos >= 0) { chars[insertPos] = ch; insertPos--; }
        }
      }
      smokeBuf[j] = chars.join('');
    }
  }

  let offset = 0;
  let smokeTick = 0;
  const intervalMs = 140;

  setInterval(() => {
    offset = (offset + 1) % wavePattern.length;
    smokeTick++;

    if (smokeRows.length) {
      smokeBuf = smokeBuf.map(driftAndFadeRow);
      if (smokeTick % 2 === 0) {
        smokeBuf = smokeBuf.slice(1).concat([makeSeedRow()]);
      }
    }

    const out = lines.map((line, i) => {
      const runs = runsByLine[i];
      if (!runs || runs.length === 0) return line;
      const chars = line.split('');
      for (const r of runs) {
        const need = r.len;
        const repeatCount = Math.ceil((need + offset) / wavePattern.length) + 2;
        const seq = wavePattern.repeat(repeatCount).slice(offset, offset + need);
        for (let k = 0; k < need; k++) chars[r.start + k] = seq[k];
      }
      return chars.join('');
    });

    if (smokeRows.length && stackCol > 0) {
      for (let j = 0; j < smokeRows.length; j++) {
        const row = smokeRows[j];
        out[row] = clearFromCol(out[row], stackCol);
      }
    }

    if (smokeRows.length) {
      for (let j = 0; j < smokeRows.length; j++) {
        const row = smokeRows[j];
        out[row] = overlay(out[row], smokeStart, smokeBuf[j]);
      }
    }

    boatEl.textContent = out.join('\n');
  }, intervalMs);
})();
</script>
</body>
</html>